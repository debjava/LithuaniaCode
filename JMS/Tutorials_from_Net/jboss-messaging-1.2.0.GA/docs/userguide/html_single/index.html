<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>JBoss Messaging 1.2 User's Guide</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>JBoss Messaging 1.2 User's Guide</h1></div><div><h2 class="subtitle">The next generation enterprise messaging solution from JBoss</h2></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#about">1. Introducing JBoss Messaging Release 1.2.0.GA</a></span></dt><dt><span class="chapter"><a href="#introduction">2. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#support">2.1. JBoss Messaging support cover from Red Hat</a></span></dt><dt><span class="section"><a href="#features">2.2. JBoss Messaging 1.2.0.GA Features</a></span></dt><dt><span class="section"><a href="#compatibility">2.3. Compatibility with JBossMQ</a></span></dt><dt><span class="section"><a href="#missingfeatures">2.4. 
      Features not yet available in the 1.2.0.GA release, but coming soon
      </a></span></dt></dl></dd><dt><span class="chapter"><a href="#c_overview">3. JBoss Messaging Clustering</a></span></dt><dd><dl><dt><span class="section"><a href="#clustering_overview">3.1. JBoss Messaging Clustering Overview</a></span></dt><dt><span class="section"><a href="#clustering_architectural_overview">3.2. Clustering Architectural Overview</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gettingstarted">4. Download Software</a></span></dt><dd><dl><dt><span class="section"><a href="#releasebundle">4.1. The JBoss Messaging Release Bundle</a></span></dt><dt><span class="section"><a href="#SVN">4.2. SVN Access</a></span></dt></dl></dd><dt><span class="chapter"><a href="#installation">5. JBoss Messaging Non-Clustered Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#install4">5.1. Installing JBoss Messaging with JBoss AS 4.0.x and 4.2.1</a></span></dt><dd><dl><dt><span class="section"><a href="#install4.automated">5.1.1. Installation procedure</a></span></dt></dl></dd><dt><span class="section"><a href="#startingtheservice">5.2. Starting the Server</a></span></dt><dt><span class="section"><a href="#inst.validation">5.3. Installation Validation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#c_installation">6. JBoss Messaging Clustered Installation</a></span></dt><dt><span class="chapter"><a href="#examples">7. Running the Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.queue">7.1. Sending messages to a queue</a></span></dt><dt><span class="section"><a href="#examples.topic">7.2. Sending messages to a topic</a></span></dt><dt><span class="section"><a href="#examples.stateless">7.3. Using JMS from an EJB</a></span></dt><dt><span class="section"><a href="#examples.mdb.ejb21">7.4. Using EJB2.1 Message Driven Beans</a></span></dt><dt><span class="section"><a href="#examples.mdb.ejb3">7.5. Using EJB3 Message Driven Beans</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">8. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.serverpeer">8.1. Configuring the ServerPeer</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.serverpeer.attributes">8.1.1. 
             We now discuss the MBean attributes of the ServerPeer MBean
        </a></span></dt><dd><dl><dt><span class="section"><a href="#conf.serverpeer.attributes.persistencemanager">8.1.1.1. PersistenceManager</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.postoffice">8.1.1.2. PostOffice</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.jmsusermanager">8.1.1.3. JMSUserManager</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultdlq">8.1.1.4. DefaultDLQ</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultexpiryqueue">8.1.1.5. DefaultExpiryQueue</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.serverpeerid">8.1.1.6. ServerPeerID</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultqueuejndicontext">8.1.1.7. DefaultQueueJNDIContext</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultopicjndicontext">8.1.1.8. DefaultTopicJNDIContext</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.destinations">8.1.1.9. Destinations</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultmaxdeliveryattempts">8.1.1.10. DefaultMaxDeliveryAttempts</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.failoverstarttimeout">8.1.1.11. FailoverStartTimeout</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.failovercompletetimeout">8.1.1.12. FailoverCompleteTimeout</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultredliverydelay">8.1.1.13. DefaultRedeliveryDelay</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.queuestatssampleperiod">8.1.1.14. QueueStatsSamplePeriod</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultmessagecounterhistorydaylimit">8.1.1.15. DefaultMessageCounterHistoryDayLimit</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.messagecounters">8.1.1.16. MessageCounters</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.messagecounterstatistics">8.1.1.17. MessageCountersStatistics</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.attributes.defaultsecurity">8.1.1.18. DefaultSecurityConfig</a></span></dt></dl></dd><dt><span class="section"><a href="#conf.serverpeer.operations">8.1.2. 
             We now discuss the MBean operations of the ServerPeer MBean
        </a></span></dt><dd><dl><dt><span class="section"><a href="#conf.serverpeer.operations.deployQueue">8.1.2.1. DeployQueue</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.undeployQueue">8.1.2.2. UndeployQueue</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.destroyQueue">8.1.2.3. DestroyQueue</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.deployTopic">8.1.2.4. DeployTopic</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.undeployTopic">8.1.2.5. UndeployTopic</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.destroyTopic">8.1.2.6. DestroyTopic</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.listmessagecountersashtml">8.1.2.7. ListMessageCountersHTML</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.resetallmessagecounters">8.1.2.8. ResetAllMesageCounters</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.resetallmessagecounterhistories">8.1.2.9. ResetAllMesageCounters</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.enablemessagecounters">8.1.2.10. EnableMessageCounters</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.disablemessagecounters">8.1.2.11. DisableMessageCounters</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.retrievepreparedtransactions">8.1.2.12. RetrievePreparedTransactions</a></span></dt><dt><span class="section"><a href="#conf.serverpeer.operations.showpreparedtransactions">8.1.2.13. ShowPreparedTransactions</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#conf.changingds">8.2. Changing the Database</a></span></dt><dt><span class="section"><a href="#conf.postoffice">8.3. Configuring the Post office</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.postoffice.nonclustered">8.3.1. Non clustered post office</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.postoffice.nonclustered.attributes">8.3.1.1. The non clustered post office has the following attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#conf.postoffice.clustered">8.3.2. Clustered post office</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.postoffice.clustered.attributes">8.3.2.1. The nclustered post office has the following attributes</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#conf.persistencemanager">8.4. Configuring the Persistence Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.persistencemanager.attributes">8.4.1. 
        We now discuss the MBean attributes of the PersistenceManager MBean
        </a></span></dt><dd><dl><dt><span class="section"><a href="#conf.persistencemanager.attributes.createtables">8.4.1.1. CreateTablesOnStartup</a></span></dt><dt><span class="section"><a href="#conf.persistencemanager.attributes.batchupdates">8.4.1.2. UsingBatchUpdates</a></span></dt><dt><span class="section"><a href="#conf.persistencemanager.attributes.binarystream">8.4.1.3. UsingBinaryStream</a></span></dt><dt><span class="section"><a href="#conf.persistencemanager.attributes.trailingbyte">8.4.1.4. UsingTrailingByte</a></span></dt><dt><span class="section"><a href="#conf.persistencemanager.attributes.sqlproperties">8.4.1.5. SQLProperties</a></span></dt><dt><span class="section"><a href="#conf.persistencemanager.attributes.maxparams">8.4.1.6. MaxParams</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#conf.jmsusermanager">8.5. Configuring the JMS user manager</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.jmsusermanager.attributes">8.5.1. 
        We now discuss the MBean attributes of the PersistenceManager MBean
        </a></span></dt><dd><dl><dt><span class="section"><a href="#conf.jmsusermanager.attributes.createtables">8.5.1.1. CreateTablesOnStartup</a></span></dt><dt><span class="section"><a href="#conf.jmsusermanager.attributes.batchupdates">8.5.1.2. UsingBatchUpdates</a></span></dt><dt><span class="section"><a href="#conf.jmsusermanager.attributes.sqlproperties">8.5.1.3. SQLProperties</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#conf.destination">8.6. Configuring Destinations</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.preconf.destinations">8.6.1. Pre-configured destinations</a></span></dt><dt><span class="section"><a href="#conf.destination.queue">8.6.2. Configuring queues</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.destination.queue.attributes">8.6.2.1. 
            We now discuss the MBean attributes of the Queue MBean
            </a></span></dt><dt><span class="section"><a href="#conf.destination.queue.operations">8.6.2.2. 
             We now discuss the MBean operations of the Queue MBean
         </a></span></dt></dl></dd><dt><span class="section"><a href="#conf.destination.topics">8.6.3. Configuring topics</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.destination.topic.attributes">8.6.3.1. 
            We now discuss the MBean attributes of the Topic MBean
            </a></span></dt><dt><span class="section"><a href="#conf.destination.topic.operations">8.6.3.2. 
             We now discuss the MBean operations of the Topic MBean
         </a></span></dt></dl></dd><dt><span class="section"><a href="#conf.destination.new">8.6.4. Deploying a new destination</a></span></dt></dl></dd><dt><span class="section"><a href="#conf.connections">8.7. Configuring Connection Factories</a></span></dt><dd><dl><dt><span class="section"><a href="#conf.connectionfactory.attributes">8.7.1. 
           We now discuss the MBean attributes of the ConnectionFactory MBean
       </a></span></dt><dd><dl><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.clientid">8.7.1.1. ClientID</a></span></dt><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.jndibindings">8.7.1.2. JNDIBindings</a></span></dt><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.prefetchsize">8.7.1.3. PrefetchSize</a></span></dt><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.tempqueuepaging">8.7.1.4. Temporary queue paging parameters</a></span></dt><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.dupsokbatchsize">8.7.1.5. DupsOKBatchSize</a></span></dt><dt><span class="section"><a href="#conf.destination.connectionfactory.attributes.connector">8.7.1.6. Connector</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#conf.connector">8.8. Configuring the remoting connector</a></span></dt><dt><span class="section"><a href="#conf.servicebindingmanager">8.9. ServiceBindingManager</a></span></dt><dt><span class="section"><a href="#conf.callback">8.10. Configuring the callback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#c_configuration">9. JBoss Messaging Clustering Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#clusterrouter">9.1. Choosing the cluster router policy</a></span></dt><dt><span class="section"><a href="#messagepull">9.2. Choosing the message pull policy</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">10. Generating Performance Benchmark Results</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2210">10.1. Run JBoss Messaging and JBossMQ Side-by-side</a></span></dt><dt><span class="section"><a href="#d0e2249">10.2. Setup the Tests</a></span></dt><dt><span class="section"><a href="#d0e2277">10.3. Configure Test Runs</a></span></dt><dt><span class="section"><a href="#d0e2297">10.4. Run the Tests</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="about"></a>Chapter&nbsp;1.&nbsp;Introducing JBoss Messaging Release 1.2.0.GA</h2></div></div><div></div></div><p>
       JBoss Messaging is a high performance JMS provider in the JBoss Enterprise Middleware Stack
       (JEMS). It is a complete rewrite of JBossMQ, which is the current default JMS provider in
       JBoss AS 4.0.x series and JBoss AS 4.2.0. JBoss Messaging will be the default JMS provider in
       JBoss AS 4.2.x series, probably starting with 4.2.1, and it is already the default provider
       in JBoss 5.0.0.Beta.
   </p><p>JBoss Messaging it is also the backbone of the JBoss ESB infrastructure.</p><p>
       Compared with JBossMQ, JBoss Messaging offers vastly improved performance in both single node
       and clustered environments.
       Please see
       <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossMessagingPerformanceResultsPre1_0" target="_top">this wiki page</a>
       for performance benchmarks and <a href="#performance" title="Chapter&nbsp;10.&nbsp;Generating Performance Benchmark Results">Chapter&nbsp;10, <i>Generating Performance Benchmark Results</i></a> on how to generate your own
       performance benchmarks. JBoss Messaging also features a much better modular architecture that
       will allow us to add more features in the future.
   </p><p>
       While JBoss Messaging only becomes the default JMS provider from JBoss AS 4.2.1 and JBoss 5.0,
       production users on JBoss AS 4.0.x can still take advantage of the performance improvements
       by easily replacing the JBossMQ module with JBoss Messaging.
   </p><p>
       The procedure of swapping JMS providers is presented in detail in this manual.
       In <a href="#installation" title="Chapter&nbsp;5.&nbsp;JBoss Messaging Non-Clustered Installation">Chapter&nbsp;5, <i>JBoss Messaging Non-Clustered Installation</i></a> we discuss how to install and use JBoss Messaging in
       JBoss 4.0.x production servers. We cover JBoss Messaging-specific configuration options,
       as well as how to run the build-in sanity / performance tests.
   </p><p>
      This guide is work in progress, as new features will be added to the 1.2 baseline at a very
      quick pace. Please send your suggestions or comments to the
      <a href="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=238" target="_top">JBoss Messaging user forum</a>.
   </p><p>
      <span class="bold"><b>Team:</b></span>
   </p><p>
      Ovidiu Feodorov, Project Lead
   </p><p>
      Tim Fox, Technical Lead

   </p><p>
       Clebert Suconic, Core Messaging Developer
    </p><p>
      Other contributions by: Adrian Brock, Bela Ban, Alex Fu, Luc Texier, Aaron Walker,
      Rajdeep Dua, Madhusudhan Konda, Juha Lindfors and Ron Sigal.
   </p><p>
       This manual was written with help from Luc Texier, Lead Support EMEA and
       Sam Griffith Jr., JBoss Documentation Team.
   </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;2.&nbsp;Introduction</h2></div></div><div></div></div><p>
      JBoss Messaging provides an open source and standards-based messaging platform that brings
      enterprise-class messaging to the mass market.
   </p><p>
      JBoss Messaging implements a high performance, robust messaging core that is designed to
      support the largest and most heavily utilized SOAs, enterprise service buses (ESBs) and other
      integration needs ranging from the simplest to the highest demand networks.
      It will allow you to smoothly distribute your application load across your cluster,
      intelligently balancing and utilizing each nodes CPU cycles, with no single point of failure,
      providing a highly scalable and perform-ant clustering implementation. JBoss Messaging includes
      a JMS front-end to deliver messaging in a standards-based format as well as being designed to be
     able to support other messaging protocols in the future.
   </p><p>
      JBoss Messaging will soon become an integral component of the JBoss Enterprise Middleware
      Suite (JEMS). Currently it
      is available for embedded use within the JBoss Application Server (JBossAS), and as a
      JBoss Microkernel-based stand-alone server. Work to integrate JBoss Messaging with the new
      JBoss Microcontainer is under way.
   </p><p>
      The large and vibrant JEMS developer community fosters its continued innovation and
      enterprise quality. JBoss Messaging enables more agile applications in a wide range of
      scenarios from simple messaging needs to an enterprise-wide messaging foundation and adds
      flexibility to any SOA initiative.
   </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="support"></a>2.1.&nbsp;JBoss Messaging support cover from Red Hat</h2></div></div><div></div></div><p>
         JBoss Messaging 1.2.GA will become part of both Application Server Platform (JBoss 4.2
         series) and Service Integration Platform (JBoss ESB 4 series) as default JMS provider.
         Production support will be fully available for these plaforms and it will cover JBoss
         Messaging.
      </p><p>
         Red Hat is also working on introducing a development support program, which is different
         from production support and caters to companies who want to have a safety net even from
         the development phase. The estimated availability date of this support progam is April
         2007.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="features"></a>2.2.&nbsp;JBoss Messaging 1.2.0.GA Features</h2></div></div><div></div></div><p>
         JBoss Messaging provides:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
               A fully compatible and Sun certified JMS 1.1 implementation, that currently works
               with a standard JBossAS 4.0.x, 4.2.x and JBoss 5.x installation and also as a JBoss
               Microkernel-based standalone deployment.
            </p></li><li><p>
               A strong focus on performance, reliability and scalability with high throughput and
               low latency. JBoss Messaging already exceeds JBoss MQ in a number of measured
               performance metrics. Full results will follow.
            </p></li><li><p>
               A foundation for JBoss ESB for SOA initiatives; JBoss ESB uses
               JBoss Messaging as its foundation.
            </p></li></ul></div><p>
         JBoss Messaging consists of two major parts:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
               JBoss Messaging Core &#8211; a transactional, reliable messaging transport system.
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                     Supports generalized messages (not just JMS)
                  </p></li><li><p>
                     Enables other messaging protocol fa&ccedil;ades to be added
                  </p></li><li><p>
                     Distributed, transactional and reliable
                  </p></li></ul></div></li><li><p>
               JMS Fa&ccedil;ade &#8211; the JMS "personality" of JBoss Messaging.
            </p></li></ul></div><p>
         Other JBoss Messaging features include:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
               Publish-subscribe and point-to-point messaging models
            </p></li><li><p>
               Topics that feed multiple message queues
            </p></li><li><p>
               Persistent and non-persistent messages
            </p></li><li><p>
               Guaranteed message delivery that ensures that messages arrive once and only once
            </p></li><li><p>
               Transactional and reliable  - supporting ACID semantics
            </p></li><li><p>
               Customizable security framework based on JAAS
            </p></li><li><p>
               Fully integrated with JBoss Transactions (formerly known as Arjuna JTA) for full transaction recoverability.
            </p></li><li><p>
               Extensive JMX management interface
            </p></li><li><p>
               Support for most major databases including Oracle, Sybase, MS SQL Server, PostgreSQL and MySQL
            </p></li><li><p>
               HTTP transport
            </p></li></ul></div><p>
         JBoss Messaging 1.2.0.GA Clustering provides the following features:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
               Distributed queues. Messages sent to a distributed queue while attached to a
               particular node will be routed to a queue instance on a particular node according
               to a routing policy.
            </p></li><li><p>
               Distributed topics. Messages sent to a distributed topic while attached at a
               particular node will be received by subscriptions on other nodes.
            </p></li><li><p>
               Fully reliable message distribution. Once and only once delivery is fully guaranteed.
               When sending messages to a topic with multiple durable subscriptions
               across a cluster we guarantee that message reaches all the subscriptions
               (or none of them in case of failure).
            </p></li><li><p>
                  Pluggable routing implementation. The policy for routing messages to a queue is fully
                     pluggable and easily replaceable. The default policy always chooses a queue at the local
                     node if there is one, and if not, it round robins between queues on different nodes.
            </p></li><li><p>
                  Intelligent message redistribution policy. Messages are automatically distributed between
                     nodes depending on how fast or slow consumers are on certain nodes. If there are no or slow
                     consumers on a particular queue node, messages will be pulled from that queue to a queue with
                     faster consumers on a different node. The policy is fully pluggable.
            </p></li><li><p>
                  Shared durable subscriptions. Consumers can connect to the same durable subscription while
                     attached to different nodes. This allows processing load from durable subscriptions to be
                     distributed across the cluster in a similar way to queues.
            </p></li><li><p>
                  High availability and seamless fail-over. If the node you are connected to fails, you
                     will automatically fail over to another node and will not lose any persistent messages.
                     You can carry on with your session seamlessly where you left off. Once and only once
                     delivery of persistent messages is respected at all times.
         </p></li><li><p>
               Message bridge. JBoss Messaging 1.2 contains a message bridge component which enables you to bridge messages between any two JMS1.1 destinations
               on the same or physical separate locations. (E.g. separated by a WAN)
         </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compatibility"></a>2.3.&nbsp;Compatibility with JBossMQ</h2></div></div><div></div></div><p>
         JBossMQ is the JMS implementation currently shipped within JBossAS.
         Since JBoss Messaging is JMS 1.1 and JMS 1.0.2b compatible, the JMS code  written against
         JBossMQ will run with JBoss Messaging without any changes.
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
         Even if JBoss Messaging deployment descriptors are very similar to JBoss MQ
         deployment descriptors, they are <span class="emphasis"><em>not</em></span> identical, so they will require
         some simple adjustments to get them to work with JBoss Messaging. Also, the database
         data model is completely different, so don't attempt to use JBoss Messaging with a JBossMQ
         data schema and vice-versa.
      </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="missingfeatures"></a>2.4.&nbsp;
      Features not yet available in the 1.2.0.GA release, but coming soon
      </h2></div></div><div></div></div><p>
    All the final features are available apart from:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
              In a very near future, it will be possible to guarantee persistent level reliability
               guarantee without persistence. By replicating persistent messages between nodes in
               memory, we can obtain comparable reliability levels to persisting messages to disk,
               without actually storing them to disk. However, this feature is not available
               in the 1.2.0.GA release. If you're interested in how this feature will be available,
               this is the JIRA issue you can use to track it:
               <a href="http://jira.jboss.org/jira/browse/JBMESSAGING-574" target="_top">http://jira.jboss.org/jira/browse/JBMESSAGING-574</a>
           </p></li><li><p>
                The "unreliable link scenario"
                <a href="http://jira.jboss.org/jira/browse/JBMESSAGING-676" target="_top">http://jira.jboss.org/jira/browse/JBMESSAGING-676</a>
                whose development is still on-going on a parallel branch.
            </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="c_overview"></a>Chapter&nbsp;3.&nbsp;JBoss Messaging Clustering</h2></div></div><div></div></div><p>
      This section of the userguide gives a brief overview of the features available in
        JBoss Messaging Clustering 1.2.0.GA. It gives a high level explanation of how
        clustering works.
     </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clustering_overview"></a>3.1.&nbsp;JBoss Messaging Clustering Overview</h2></div></div><div></div></div><p>
      Here's a brief overview of how clustering works in JBoss Messaging 1.2.
      </p><p>
      Clustered destinations (queues and topics) can be deployed at all or none of the nodes of
      the cluster.
      A JMS client uses HA JNDI to lookup the connection factory. A client side load balancing
      policy will automatically chose a node to connect to (This is similar to
      how EJB clustering chooses a node).
      </p><p>
      The JMS client has now made a connection to a node where it can create sessions, message
      producers and message consumers and browsers and send or consume messages,
      using the standard JMS api.
      When a distributed queue is deployed across the cluster, individual partial queues are
      deployed on each node.
      </p><p>
      When a message is sent from a message producer attached to a particular node to a
      distributed queue, a routing policy determines which partial queue will receive
      the message.
      By default the router will always pass the message to a local queue, if there is one,
      this is so we avoid unnecessary network traffic.
      If there is no local queue then a partial queue on a different node will be chosen by the
      router, by default this will be round robin between remote partial queues.
      </p><p>
      When a message is sent to a distributed topic while attached to a node, there may be
      multiple subscriptions on different nodes that need to receive the
      message. Depending on the number and location of subscriptions, the message may be multicast
      or unicast across the cluster so the other nodes can pick it up.
      (All group communication, unicast, multicast and group management is handled by JGroups.)
      </p><p>
      In the case of shared durable subscriptions, if a durable subscription with the same name
      exists on more than node, then only one of the instances needs to receive the message.
      Which one is determined by the same routing policy used to route messages to partial queues.
      All of this is accomplished without losing the reliability guarantees required by JMS.
      </p><p>
      Subscriptions (both durable and non durable) can be created on all nodes and will receive messages sent via any node.
      What happens if the consumers on one queue/subscription are faster/slower than consumers on another?
      Normally this would result in messages building up on that queue and fast consumers being starved of work on another, thus wasting CPU cycles on the node that
      could be put to good use.
      The most degenerate example is of a queue containing many messages then the consumers being closed on that queue.
      The messages might potentially remain stranded on the queue until another consumer attaches.
      A routing policy is no use here, since the messages have already been routed to the queuee and the consumers closed / slowed down
      after they were routed there.
      JBoss Messaging can deal with this problem by intelligently pulling messages from other less
      busy nodes, if it detects idle consumers on the fast node and slow consumers
      on another node.
      </p><p>
      Normally, persistent messages are persisted in a shared database which is shared by all nodes
      in the cluster.

      JBoss Messaging 1.2.1 will contain
      an option where you can choose to not persist persistent messages in a database, but instead to replicate them between nodes of the cluster.

      The idea here is the network IO on a fast network should be much faster than persisting to disk.
      This solution should also be more scalable since different nodes replicate their messages onto
      different other nodes - there is no "master node".

      If the messages are replicated onto sufficient nodes and the hardware is set-up with UPS, then we believe a comparable reliability guarantee to persisting messages to disk
      can be achieved. Of course, this won't be suitable for all situations, but you use the best tool for the job.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clustering_architectural_overview"></a>3.2.&nbsp;Clustering Architectural Overview</h2></div></div><div></div></div><p>
           One of the fundamental Messaging Core building blocks is the "Post Office". A JBoss Messaging
           Post Office is message routing component, which accepts messages for delivery and synchronously
           forwards them to their destination queues or topic subscriptions.
        </p><p>
           There is a single Post Office instance per JBoss Messaging server (cluster node). Both queues
           and topics deployed on a JBoss Messaging node are "plugged" into that Post Office instance.
           Internally JBoss Messaging only deals  with the concepts of queues, and considers a topic to
           just be a set of queues (one for each subscription). Depending on the type of subscription -
           durable or non-durable - the corresponding queue saves messages to persistent storage or
           it just holds messages in memory and discards them when the non-durable subscription is closed.
        </p><p>
           Therefore, for a JMS queue, the Post Office routes messages to one and only one core queue,
           depending on the queue name, whereas for a JMS topic, the Post Office routes a message
           to a set of core queues, one for each topic subscription, depending on the topic name.
        </p><p>
           Clustering across multiple address spaces is achieved by clustering Post Office instances. Each
           JBoss Messaging cluster node runs a Clustered Post Office instance, which is aware of the presence
           of all other clustered Post Offices in the cluster. There is an one-to-one relationship between cluster
           nodes and clustered Post Office instances. So, naturally, the most important piece of clustering
           configuration is the <span class="emphasis"><em>clustered Post Office service configuration</em></span>,
           covered in detail below.
        </p><p>
           Clustered Post Office instances connect to each other via JGroups and they heavily rely on JGroups
           group management and notification mechanisms. <span class="emphasis"><em>JGroups stack configuration</em></span>
           is an essential part of JBoss Messaging clustering configuration. JGroups configuration is only
           briefly addressed in this guide. Detailed information on JGroups can be found in JGroups
           release documentation or on-line at <a href="http://www.jgroups.org" target="_top">http://www.jgroups.org</a>
           or <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups" target="_top">http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups</a>
        </p><p>
           When routing messages, a clustered Post Office  has a choice of forwarding the message to local
           queues or remote queues, plugged into remote Post Office instances that are part of the same
           cluster. Local queues are usually preferred, but if a local queue is part of a distributed queue, has
           no consumers, and other local queues part of the same distributed queue have consumers, messages
           can be automatically redistributed, subject of the message redistribution policy in effect. This allows
           us to create distributed queues and distributed topics.  <span class="emphasis"><em>Message redistribution
           configuration</em></span> is another subject that we will insist on.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="gettingstarted"></a>Chapter&nbsp;4.&nbsp;Download Software</h2></div></div><div></div></div><p>
      The official releases of JBoss Messaging are available as a free download from
      <a href="http://www.jboss.com/products/messaging" target="_top">the JBoss Messaging project landing page</a>.
   </p><p>
       The recommended download location is the JBoss Labs Messaging Project download zone:
       <a href="http://labs.jboss.com/portal/jbossmessaging/downloads" target="_top">http://labs.jboss.com/portal/jbossmessaging/downloads</a>
       We also maintain an alternate download location on sourceforge.net:
       <a href="http://sourceforge.net/project/showfiles.php?group_id=22866&amp;package_id=157261" target="_top">http://sourceforge.net/project/showfiles.php?group_id=22866&amp;package_id=157261</a>
   </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="releasebundle"></a>4.1.&nbsp;The JBoss Messaging Release Bundle</h2></div></div><div></div></div><p>
         The JBoss Messaging release bundle (<tt class="filename">jboss-messaging-1.2.x.zip</tt>)
         will expand in a <tt class="filename">jboss-messaging-1.2.x</tt> directory that contains:
      </p><div class="itemizedlist"><ul type="disc"><li><tt class="filename">jboss-messaging-scoped.sar</tt>
            - the scoped JBoss service archive that contains JBoss Messaging and its
            dependencies.
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
               Do not simply attempt to copy the archive under a JBoss instance <tt class="filename">deploy</tt> directory,
               since additional steps (such as un-installing JBossMQ and various other configurations
               tasks) are required for a successful installation. See <a href="#installation" title="Chapter&nbsp;5.&nbsp;JBoss Messaging Non-Clustered Installation">Chapter&nbsp;5, <i>JBoss Messaging Non-Clustered Installation</i></a> for
               more details.
            </div></li><li><tt class="filename">jboss-messaging-client.jar</tt>
            - the client-side library that need to be in the classpath of the client that opens
            a remote connection to the Messaging server.

            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                This is an important note on the Messaging client jar. JBoss Messaging has an
                extensive tree of dependencies and bundling all right dependencies in one easy
                to use archive, so no wrong versions inadvertently get in the class path is, as
                experience shows, extremely convenient. However, this could cause problems if a
                different version of a dependency is required by the user's client code.
                </p><p>
                If, for example, the log4j.jar bundled with the release causes problems for being
                too old, one could just simply build the client-side class path so a newer version
                of log4j.jar precedes jboss-messaging-client.jar in that class path. This approach
                may work, but is not guaranteed to work, because we did not run the full test suite
                with any other log4j.jar version except the one we bundle with the release.

                Soon we will providing an ant task that creates a slimmed down client jar without the extra
                dependencies bundled.
                </p><p>
                 A list of required dependencies for a specific release can be found in the
                 <tt class="filename">build-thirdpary.xml</tt> file that is part of the companion source
                 bundle that ships with each release. It can also be looked up online in
                  <a href="http://fisheye.jboss.org" target="_top">http://fisheye.jboss.org</a>.
                </p></div></li><li><tt class="filename">util</tt>
            - a collection of <tt class="literal">ant</tt> configuration files used to automate
            installation and release
            management procedures. See <a href="#installation" title="Chapter&nbsp;5.&nbsp;JBoss Messaging Non-Clustered Installation">Chapter&nbsp;5, <i>JBoss Messaging Non-Clustered Installation</i></a> for
             more details.
         </li><li><tt class="filename">examples</tt>
            - a collection of examples that should run out of the box and help you validate the
            installation. Detailed instructions are provided with each example, which range from
            very simple JMS queue and topic examples to relatively sophisticated use cases in which
            EJBs and JCA JMS ConnectionFactories are involved, as well as clustering use cases.
            The <tt class="filename">examples/config</tt> sub-directory contains various configuration
            file examples.
         </li><li><tt class="filename">docs</tt>
            - this user's guide.
         </li><li><tt class="filename">src/jboss-messaging-1.2.x-src.zip</tt>
            - the zipped source directory. The file can be directly installed into and used
            with a debugger.
         </li><li><tt class="filename">test-results</tt>
            - the output of the functional testsuite, stress and smoke test runs for this release.
            All these files have been generated during the release procedure and are bundled here
            for reference.
         </li><li><tt class="filename">api</tt>
            - the Messaging API javadoc.
         </li><li><tt class="filename">README.html</tt>
            - The release intro document that contains pointers to various other resources,
            including this Guide.
         </li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SVN"></a>4.2.&nbsp;SVN Access</h2></div></div><div></div></div><p>
         If you want to experiment with the latest developments you may checkout the latest code
         from the Messaging SVN trunk. Be aware that the information provided in this manual might
         then not be accurate.
         For the latest instructions on how to check out and build source code, please go to
         <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossMessagingDevelopment" target="_top">
            Messaging Development wiki page</a>, specifically

         <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossMessagingBuildInstructions" target="_top">
          "Building and Running JBoss Messaging"</a> section.
      </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="installation"></a>Chapter&nbsp;5.&nbsp;JBoss Messaging Non-Clustered Installation</h2></div></div><div></div></div><p>
      This section describes the procedure to perfom a non-clustered installation. At the
      end of this procedure, you will create a JBoss Messaging configuration that will
      start a non-clustered messaging server. To find out how you can install JBoss Messaging
      in a clustered configuration, please proceed to <a href="#c_installation" title="Chapter&nbsp;6.&nbsp;JBoss Messaging Clustered Installation">Chapter&nbsp;6, <i>JBoss Messaging Clustered Installation</i></a>.
   </p><p>
      By default, a JBoss AS 4.0.x and 4.2.0 instance ships with JBossMQ as default JMS provider.
      In order to use the JBoss AS instance with JBoss Messaging, you need to perform the
      installation procedure described below.
   </p><p>
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
         A JBossMQ and a JBoss Messaging instance cannot coexist, at least not unless special
         precautions are taken. Do not simply attempt to copy the Messaging release artifact
         <tt class="filename">jboss-messaging-scoped.sar</tt> over to the JBoss instance
         <tt class="filename">deploy</tt> directory. Follow one of the alternate installation procedures
         outlined below instead.
      </div><p>
   </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="install4"></a>5.1.&nbsp;Installing JBoss Messaging with JBoss AS 4.0.x and 4.2.1</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
          You need Apache ant 1.7.0 or newer pre-installed on your system and available in
          you path in order to be able to perform the installation process described below.
      </div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="install4.automated"></a>5.1.1.&nbsp;Installation procedure</h3></div></div><div></div></div><p>
         Set up the <tt class="literal">JBOSS_HOME</tt> environment variable to point to
         the JBoss 4.x installation you want to use JBoss Messaging with. Run the installation
         script, available in the  <tt class="filename">util</tt> directory of the release bundle.
      </p><pre class="programlisting">
cd util
ant -f release-admin.xml
       </pre><p>
            The installation script will create a <tt class="filename">$JBOSS_HOME/server/messaging</tt>
            configuration.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
          If you want to create a JBoss Messaging configuration with a different name, modify
          the <tt class="literal">messaging.config.name</tt> system property declared at the beginning of
           the installation script accordingly.
       </div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="startingtheservice"></a>5.2.&nbsp;Starting the Server</h2></div></div><div></div></div><p>
        To run the server, execute the <tt class="filename">run.bat</tt> or <tt class="filename">run.sh</tt>
        script as appropriate for your operating system, in the <tt class="filename">$JBOSS_HOME/bin</tt>
        directory.
     </p><pre class="programlisting">
cd $JBOSS_HOME/bin
./run.sh -c messaging
   </pre><p>
        A successful JBoss Messaging deployment generates logging output similar to:
     </p><pre class="programlisting">
....
01:44:48,317 WARN  [JDBCPersistenceManager]

JBoss Messaging Warning: DataSource connection transaction isolation should be
       READ_COMMITTED, but it is currently NONE.
       Using an isolation level less strict than READ_COMMITTED may lead to data
       consistency problems.
       Using an isolation level more strict than READ_COMMITTED may lead to deadlock.

01:44:50,450 INFO  [ServerPeer] JBoss Messaging 1.2.0.GA server [0] started
01:44:51,311 INFO  [ConnectionFactory] Connector bisocket://192.168.1.104:4457 has
leasing enabled, lease period 10000 milliseconds
01:44:51,311 INFO  [ConnectionFactory] [/ConnectionFactory, /XAConnectionFactory,
java:/ConnectionFactory, java:/XAConnectionFactory] started
01:44:51,441 INFO  [ConnectionFactory] Connector bisocket://192.168.1.104:4457 has
leasing enabled, lease period 10000 milliseconds
01:44:51,441 INFO  [ConnectionFactory] [/NonClusteredConnectionFactory,
/NonClusteredXAConnectionFactory, java:/NonClusteredConnectionFactory,
java:/NonClusteredXAConnectionFactory] started
01:44:51,681 INFO  [QueueService] Queue[/queue/DLQ] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,681 INFO  [QueueService] Queue[/queue/ExpiryQueue] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,732 INFO  [TopicService] Topic[/topic/testTopic] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,732 INFO  [TopicService] Topic[/topic/securedTopic] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,732 INFO  [TopicService] Topic[/topic/testDurableTopic] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,752 INFO  [QueueService] Queue[/queue/testQueue] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,752 INFO  [QueueService] Queue[/queue/A] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,762 INFO  [QueueService] Queue[/queue/B] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,762 INFO  [QueueService] Queue[/queue/C] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,882 INFO  [QueueService] Queue[/queue/D] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,882 INFO  [QueueService] Queue[/queue/ex] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,882 INFO  [QueueService] Queue[/queue/PrivateDLQ] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,892 INFO  [QueueService] Queue[/queue/PrivateExpiryQueue] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,892 INFO  [QueueService] Queue[/queue/QueueWithOwnDLQAndExpiryQueue] started,
fullSize=200000, pageSize=2000, downCacheSize=2000
01:44:51,892 INFO  [TopicService] Topic[/topic/TopicWithOwnDLQAndExpiryQueue] started,
fullSize=200000, pageSize=2000, downCacheSize=2000
01:44:51,942 INFO  [QueueService] Queue[/queue/QueueWithOwnRedeliveryDelay] started,
fullSize=200000, pageSize=2000, downCacheSize=2000
01:44:51,942 INFO  [TopicService] Topic[/topic/TopicWithOwnRedeliveryDelay] started,
fullSize=200000, pageSize=2000, downCacheSize=2000
01:44:51,952 INFO  [QueueService] Queue[/queue/testDistributedQueue] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:51,952 INFO  [TopicService] Topic[/topic/testDistributedTopic] started, fullSize=200000,
pageSize=2000, downCacheSize=2000
01:44:52,372 INFO  [ConnectionFactoryBindingService] Bound ConnectionManager
'jboss.jca:name=JmsXA,service=ConnectionFactoryBinding' to JNDI name 'java:JmsXA'
....
   </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        The warning message <tt class="literal">DataSource connection transaction isolation should be READ_COMMITTED,
        but it is currently NONE</tt>
        is there to remind you that by default JBossAS ships with Hypersonic, an in-memory
        Java-based database engine, which is apropriate for demo purposes, but not for heavy load
        production environments. The
        <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=ConfigJBossMQDB" target="_top">Critique of Hypersonic</a>
        wiki page outlines some of the well-known issues occuring when using this database.
     </div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
        Before using Messaging in production, you <span class="emphasis"><em>must</em></span> configure
        the Messaging instance to use an enterprise-class database backend such as MySQL or Oracle,
        otherwise you risk losing your data.
        See <a href="#conf.changingds" title="8.2.&nbsp;Changing the Database">Section&nbsp;8.2, &#8220;Changing the Database&#8221;</a> for details about replacing Hypersonic.
     </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inst.validation"></a>5.3.&nbsp;Installation Validation</h2></div></div><div></div></div><p>
        The release bundle contains a series of examples that should run "out of the box" and
        could be used to validate a new installation. Such an example sends a persistent JMS message
        to a queue called <tt class="literal">queue/testQueue</tt>.
     </p><p>
       To run the example and validate the installation,
       open an new command line window and set the <tt class="literal">JBOSS_HOME</tt>
       environment variable to point to the JBoss AS 4.x installation you've just installed
       Messaging on. Navigate to the folder where
       you extracted the release bundle and drill down to <tt class="filename">/examples/queue</tt>.
       Apache Ant must pe present in your path in order to be able to run the example.
    </p><pre class="programlisting">

setenv JBOSS_HOME=&lt;your_JBoss_installation&gt;
cd .../examples/queue
$ant

   </pre><p>
        A successfull execution log output looks similar to:
     </p><pre class="programlisting">
$ ant
Buildfile: build.xml

identify:
[echo] ###########################################################################
[echo] #                       Running the QUEUE example                         #
[echo] ###########################################################################
[echo] The queue:      testQueue
[echo] The client jar: ../../../output/lib/jboss-messaging-client.jar

sanity-check:

init:
[mkdir] Created dir: c:\work\src\svn\messaging\docs\examples\queue\output
[mkdir] Created dir: c:\work\src\svn\messaging\docs\examples\common\output

compile:
[javac] Compiling 5 source files to c:\work\src\svn\messaging\docs\examples\common\output
[javac] Compiling 1 source file to c:\work\src\svn\messaging\docs\examples\queue\output

run:
   [java] Queue /queue/testQueue exists
   [java] The message was successfully sent to the testQueue queue
   [java] Received message: Hello!
   [java] The example connected to JBoss Messaging version 1.2.0.GA (1.2)
   [java]
   [java] #####################
   [java] ###    SUCCESS!   ###
   [java] #####################

BUILD SUCCESSFUL
Total time: 9 seconds
</pre><p>
        It is recommended to run <tt class="literal">all</tt> validation examples available in the
        <tt class="filename">example</tt> directory (<tt class="filename">queue</tt>,
        <tt class="filename">topic</tt>, <tt class="filename">mdb</tt>, <tt class="filename">stateless</tt>, etc.).
         In <a href="#examples" title="Chapter&nbsp;7.&nbsp;Running the Examples">Chapter&nbsp;7, <i>Running the Examples</i></a>, we will have a look at each of those examples.
     </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="c_installation"></a>Chapter&nbsp;6.&nbsp;JBoss Messaging Clustered Installation</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        You need Apache ant 1.7.0 or newer pre-installed on your system and available in
        you path in order to be able to perform the installation process described below.
    </div><p>
      Use the <tt class="filename">release-admin.xml</tt> ant script shipped with the release to
      create individual cluster node configurations.
   </p><p>
      The typical usage is:
   </p><pre class="programlisting">
cd util
ant -f release-admin.xml [-Did=node-id] [-Dports=port-config-label]
[-Ddatabase=db-name] cluster-node
   </pre><p>
      where:
      </p><div class="itemizedlist"><ul type="disc"><li><tt class="filename">node-id</tt> is the unique node ID, an integer that must be unique per
            cluster. If not specified, it defaults to 0.
         </li><li><tt class="filename">port-config-label</tt> is a binding manager server configuration label.

            The short story behind this parameter is the following: multiple application servers
            running on the same physical machine need to use different service port ranges to avoid
            port conflicts. You can configure the whole port range used by a server instance
            by enabling a special service, the binding management service, and specifiying a
            "server" configuration in the binding manager's configuration file, which will determine
            specific port values to use when starting that instance.

            The Messaging installation script can enable the service binding manager and performs
            all configuration changes automatically. You only need to specify the "server"
            configuration you want to use, as 'port-config-label'.

            If you plan to run your clustering nodes on different physical machines, this parameter
            is irrelevant, and you should not use it. However, if you install two (or more) nodes of
            your cluster on the same physical machine, you need to give the value corresponding to
            a specific "server" configurations in the binding manager configuration file. JBoss AS
            ships "out-of-the-box" with several pre-configured port ranges: 'ports-default',
            'ports-01', 'ports-02', 'ports-03'. Use one of these.

            If -Dports is not specified, the clustered instance created this way will fall over to
            the default port range for a JBoss instace.

            More details about the binding management service can be found in the Application Server
            documentation, at the following address
            <a href="http://docs.jboss.com/jbossas/guides/j2eeguide/r2/en/html_single/#ch10.bindingmanager" target="_top">http://docs.jboss.com/jbossas/guides/j2eeguide/r2/en/html_single/#ch10.bindingmanager</a></li><li><tt class="filename">db-name</tt> is the name of the database you want to create the configurations for. Supported database names are: mysql, oracle,
            postgresql, mssql, and sybase. Notice that if you create database configuration to any database other than MySQL, you will still need to
            manually install the database JDBC drivers (MySQL drivers are provided as part of the distribution).
         </li></ul></div><p>
   </p><p>
      Notice that you should have environment variable JBOSS_HOME correctly set to point to your JBoss AS distribution directory before executing any of the
      scripts.
   </p><p>
      For example, in order to create the configuration for a four-node cluster intended to run
      on the same physical machine, use the following sequence:
   </p><pre class="programlisting">
ant -f release-admin.xml cluster-node
ant -f release-admin.xml -Did=1 -Dports=ports-01 cluster-node
ant -f release-admin.xml -Did=2 -Dports=ports-02 cluster-node
ant -f release-admin.xml -Did=3 -Dports=ports-03 cluster-node
   </pre><p>
      The sequence will create four cluster node configurations ("messaging-node0",
      "messaging-node1", "messaging-node2" and "messaging-node3").
   </p><p>
      The first command will create a cluster node with ID equals to '0' and using the
      default JBoss AS port assignments.
   </p><p>
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
         The configuration that has just been created uses a generic mysql service descriptor.

         Check <tt class="filename">$JBOSS_HOME/server/messaging-node&lt;id&gt;/deploy/mysql-ds.xml</tt>
         and verify that that:
         <div class="itemizedlist"><ul type="disc"><li>1. Your database is indeed mysql.</li><li>2. It is accessible from every physical node you installed Messaging on.</li><li>3. Contains a schema (database/tablespace) named 'messaging'.</li><li>4. The URL (hostname and port), username and password are correct.</li><li>5. The installed mysql-driver.jar's version maches your database.</li></ul></div></div><p>
      </p><p>
      To start the cluster, from four different terminals, run:
      </p><pre class="programlisting">
cd $JBOSS_HOME/bin
./run.sh -c messaging-node0

cd $JBOSS_HOME/bin
./run.sh -c messaging-node1

cd $JBOSS_HOME/bin
./run.sh -c messaging-node2

cd $JBOSS_HOME/bin
./run.sh -c messaging-node3
    </pre><p>
      A successful two node cluster startup produces a log similar to:
   </p><p>
      Node 0:
   </p><pre class="programlisting">
...

00:24:04,796 WARN  [JDBCPersistenceManager]

JBoss Messaging Warning:
   DataSource connection transaction isolation should be READ_COMMITTED, but it
   is currently REPEATABLE_READ.
  Using an isolation level less strict than READ_COMMITTED may lead to data
   consistency problems.
  Using an isolation level more strict than READ_COMMITTED may lead to deadlock.

00:24:05,718 INFO  [ServerPeer] JBoss Messaging 1.2.0.CR1 server [0] started
00:24:06,328 INFO  [STDOUT]
-------------------------------------------------------
GMS: address is 127.0.0.1:2452
-------------------------------------------------------
00:24:08,406 INFO  [DefaultClusteredPostOffice] ClusteredPostOffice
[0:Clustered JMS:127.0.0.1:2452] got new view [127.0.0.1:2452|0] [127.0.0.1:2452]
00:24:08,468 INFO  [STDOUT]
-------------------------------------------------------
GMS: address is 127.0.0.1:2455
-------------------------------------------------------
00:24:10,906 INFO  [ConnectionFactory] Connector socket://10.11.14.105:4457 has leasing
enabled, lease period 10000 milliseconds
00:24:10,921 INFO  [ConnectionFactory] [/ConnectionFactory, /XAConnectionFactory,
java:/ConnectionFactory, java:/XAConnectionFactory] started
00:24:10,953 INFO  [QueueService] Queue[/queue/DLQ] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,953 INFO  [QueueService] Queue[/queue/ExpiryQueue] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,953 INFO  [TopicService] Topic[/topic/testTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,953 INFO  [TopicService] Topic[/topic/securedTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [TopicService] Topic[/topic/testDurableTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/testQueue] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/A] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/B] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/C] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/D] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,968 INFO  [QueueService] Queue[/queue/ex] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [QueueService] Queue[/queue/PrivateDLQ] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [QueueService] Queue[/queue/PrivateExpiryQueue] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [QueueService] Queue[/queue/QueueWithOwnDLQAndExpiryQueue] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [TopicService] Topic[/topic/TopicWithOwnDLQAndExpiryQueue] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [QueueService] Queue[/queue/QueueWithOwnRedeliveryDelay] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:24:10,984 INFO  [TopicService] Topic[/topic/TopicWithOwnRedeliveryDelay] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:24:11,000 INFO  [QueueService] Queue[/queue/testDistributedQueue] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:11,000 INFO  [TopicService] Topic[/topic/testDistributedTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:24:11,093 INFO  [ConnectionFactoryBindingService] Bound
ConnectionManager'jboss.jca:name=JmsXA,service=ConnectionFactoryBinding' to JNDI
name 'java:JmsXA'
00:24:11,375 INFO  [TomcatDeployer] deploy, ctxPath=/jmx-console,
warUrl=.../deploy/jmx-console.war/
00:24:12,171 INFO  [Http11BaseProtocol] Starting Coyote HTTP/1.1 on http-0.0.0.0-8080
00:24:12,421 INFO  [ChannelSocket] JK: ajp13 listening on /0.0.0.0:8009
00:24:12,453 INFO  [JkMain] Jk running ID=0 time=0/47  config=null
00:24:12,515 INFO  [Server] JBoss (MX MicroKernel) [4.0.5.GA (build: CVSTag=Branch_4_0
date=200611221632)]
Started in 30s:375ms

00:27:21,343 INFO  [DefaultClusteredPostOffice] ClusteredPostOffice
[0:Clustered JMS:127.0.0.1:2452] got new view [127.0.0.1:2452|1]
[127.0.0.1:2452, 127.0.0.1:2474]

</pre><p>
      Node 1:
   </p><pre class="programlisting">

...

00:33:54,468 WARN  [JDBCPersistenceManager]

JBoss Messaging Warning:
DataSource connection transaction isolation should be READ_COMMITTED, but it is
currently REPEATABLE_READ.
Using an isolation level less strict than READ_COMMITTED may lead to data consistency
problems.
Using an isolation level more strict than READ_COMMITTED may lead to deadlock.

00:33:55,062 INFO  [ServerPeer] JBoss Messaging 1.2.0.CR1 server [1] started
00:33:55,609 INFO  [STDOUT]
-------------------------------------------------------
GMS: address is 127.0.0.1:2514
-------------------------------------------------------
00:33:57,734 INFO  [DefaultClusteredPostOffice]
ClusteredPostOffice[1:Clustered JMS:127.0.0.1:2514] got new
view [127.0.0.1:2452|3] [127.0.0.1:2452, 127.0.0.1:2514]
00:33:57,765 INFO  [STDOUT]
-------------------------------------------------------
GMS: address is 127.0.0.1:2519
-------------------------------------------------------
00:34:00,203 INFO  [ConnectionFactory] Connector socket://10.11.14.105:4557 has leasing
enabled, lease period 20000 milliseconds
00:34:00,203 INFO  [ConnectionFactory] [/ConnectionFactory, /XAConnectionFactory,
java:/ConnectionFactory, java:/XAConnectionFactory] started
00:34:00,234 INFO  [QueueService] Queue[/queue/DLQ] started, fullSize=75000, pageSize=2000,
downCacheSize=2000
00:34:00,234 INFO  [QueueService] Queue[/queue/ExpiryQueue] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,234 INFO  [TopicService] Topic[/topic/testTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [TopicService] Topic[/topic/securedTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [TopicService] Topic[/topic/testDurableTopic] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/testQueue] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/A] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/B] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/C] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/D] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,250 INFO  [QueueService] Queue[/queue/ex] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [QueueService] Queue[/queue/PrivateDLQ] started, fullSize=75000,
pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [QueueService] Queue[/queue/PrivateExpiryQueue] started,
fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [QueueService] Queue[/queue/QueueWithOwnDLQAndExpiryQueue]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [TopicService] Topic[/topic/TopicWithOwnDLQAndExpiryQueue]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [QueueService] Queue[/queue/QueueWithOwnRedeliveryDelay]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,265 INFO  [TopicService] Topic[/topic/TopicWithOwnRedeliveryDelay]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,296 INFO  [QueueService] Queue[/queue/testDistributedQueue]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,296 INFO  [TopicService] Topic[/topic/testDistributedTopic]
started, fullSize=75000, pageSize=2000, downCacheSize=2000
00:34:00,343 INFO  [ConnectionFactoryBindingService] Bound
ConnectionManager 'jboss.jca:name=JmsXA,
service=ConnectionFactoryBinding' to JNDI name 'java:JmsXA'
00:34:00,453 INFO  [TomcatDeployer] deploy, ctxPath=/jmx-console,
warUrl=.../deploy/jmx-console.war/
00:34:00,796 INFO  [Http11BaseProtocol] Starting Coyote HTTP/1.1 on http-0.0.0.0-8180
00:34:01,078 INFO  [ChannelSocket] JK: ajp13 listening on /0.0.0.0:8109
00:34:01,125 INFO  [JkMain] Jk running ID=0 time=0/125  config=null
00:34:01,125 INFO  [Server] JBoss (MX MicroKernel)
[4.0.5.GA (build: CVSTag=Branch_4_0 date=200611221632)] Started in 22s:547ms


   </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      The installation script may fail while installing Messaging with source-generated
      JBoss 4.0.5.GA-ejb3 instance. This is because release-admin.xml relies on finding
      <tt class="filename">$JBOSS_HOME/docs/examples/binding-manager/sample-bindings.xml</tt>.
      4.0.5.GA-ejb3 installations seem not to have a "docs" sub-directory. A very simple work-around
      for this situation is to recursively copy the "docs" sub-directory available under a regular
      (non-EJB3) source-generated 4.0.5.GA instance and retry the installation process.
   </div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>Chapter&nbsp;7.&nbsp;Running the Examples</h2></div></div><div></div></div><p>
      Since JBoss Messaging is a fully compliant JMS 1.1 provider, it supports the entire JMS 1.1 API. So, all
      JMS applications should work without modification. Integrated inside a JBoss AS, we should
      also be able access the JMS system from EJBs and write message-driven beans against JMS
      destinations.
  </p><p>
      In the following sections, we will look at examples of the various JMS messaging models
      and message-driven beans. They make use of pre-configured JMS destinations and connection
      factories that come default with the server. So, no extra configuration is needed to run
      those examples. Just set JBOSS_HOME and run <tt class="literal">ant</tt> in each example
      directory, as we described in <a href="#inst.validation" title="5.3.&nbsp;Installation Validation">Section&nbsp;5.3, &#8220;Installation Validation&#8221;</a>. The example source
      directories are located in the distribution under <tt class="literal">docs/examples</tt>.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples.queue"></a>7.1.&nbsp;Sending messages to a queue</h2></div></div><div></div></div><p>
    Open an new command line. Set the JBOSS_HOME environment variable to point at a JBossAS 4.x
    installation. Navigate to the folder where you exploded the main archive and drill down to
    <tt class="literal">/examples/queue</tt>. You need to use Apache <tt class="literal">ant</tt> to execute
    the <tt class="literal">build.xml</tt> file.
    </p><p>
        Make sure the JBoss server reference by the JBOSS_HOME is started.
   </p><pre class="programlisting">
public class QueueExample extends ExampleSupport
{

   public void example() throws Exception
   {
      String destinationName = getDestinationJNDIName();

      InitialContext ic = null;
      ConnectionFactory cf = null;
      Connection connection =  null;

      try
      {
         ic = new InitialContext();

         cf = (ConnectionFactory)ic.lookup("/ConnectionFactory");
         Queue queue = (Queue)ic.lookup(destinationName);
         log("Queue " + destinationName + " exists");

         connection = cf.createConnection();
         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
         MessageProducer sender = session.createProducer(queue);

         TextMessage message = session.createTextMessage("Hello!");
         sender.send(message);
         log("The message was successfully sent to the " + queue.getQueueName() + " queue");

         MessageConsumer consumer =  session.createConsumer(queue);

         connection.start();

         message = (TextMessage)consumer.receive(2000);
         log("Received message: " + message.getText());
         assertEquals("Hello!", message.getText());

         displayProviderInfo(connection.getMetaData());

      }
      finally
      {
         if(ic != null)
         {
            try
            {
               ic.close();
            }
            catch(Exception e)
            {
               throw e;
            }
         }

         // ALWAYS close your connection in a finally block to avoid leaks.
         // Closing connection also takes care of closing its related objects e.g. sessions.
         closeConnection(connection);
      }
   }

   private void closeConnection(Connection con)
   {
      try
      {
         if (con != null)
         {
            con.close();
         }
      }
      catch(JMSException jmse)
      {
         log("Could not close connection " + con +" exception was " + jmse);
      }
   }

   protected boolean isQueueExample()
   {
      return true;
   }

   public static void main(String[] args)
   {
      new QueueExample().run();
   }

}
    </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples.topic"></a>7.2.&nbsp;Sending messages to a topic</h2></div></div><div></div></div><p>In this example, a standalone Java client publishes a text-based JMS message to a topic and a single subscriber pulls the message off the queue.
    </p><p>
    Open an new command line. Set the JBOSS_HOME environment variable to point at a JBossAS 4.x installation. Navigate to the folder where you exploded the main archive and drill down to <tt class="literal">/examples/queue</tt>. You need to use Apache Ant to execute the build.xml file
    Make sure the JBoss server reference by the JBOSS_HOME is started.
   </p><pre class="programlisting">
public class TopicExample extends ExampleSupport
{
   public void example() throws Exception
   {
      String destinationName = getDestinationJNDIName();

      InitialContext ic = null;
      Connection connection = null;

      try
      {
         ic = new InitialContext();

         ConnectionFactory cf = (ConnectionFactory)ic.lookup("/ConnectionFactory");
         Topic topic = (Topic)ic.lookup(destinationName);
         log("Topic " + destinationName + " exists");

         connection = cf.createConnection();
         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
         MessageProducer publisher = session.createProducer(topic);
         MessageConsumer subscriber = session.createConsumer(topic);

         ExampleListener messageListener = new ExampleListener();
         subscriber.setMessageListener(messageListener);
         connection.start();

         TextMessage message = session.createTextMessage("Hello!");
         publisher.send(message);
         log("The message was successfully published on the topic");

         messageListener.waitForMessage();

         message = (TextMessage)messageListener.getMessage();
         log("Received message: " + message.getText());
         assertEquals("Hello!", message.getText());

         displayProviderInfo(connection.getMetaData());

      }
      finally
      {
         if (ic != null)
         {
            try
            {
               ic.close();
            }
            catch(Exception e)
            {
               throw e;
            }
         }

         // ALWAYS close your connection in a finally block to avoid leaks.
         // Closing connection also takes care of closing its related objects e.g. sessions.
         closeConnection(connection);
      }
   }

   private void closeConnection(Connection con) throws JMSException
   {

      try
      {
         if (con != null)
         {
            con.close();
         }
      }
      catch(JMSException jmse)
      {
         log("Could not close connection " + con +" exception was " + jmse);
      }
   }

   protected boolean isQueueExample()
   {
      return false;
   }

   public static void main(String[] args)
   {
      new TopicExample().run();
   }

}
   </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples.stateless"></a>7.3.&nbsp;Using JMS from an EJB</h2></div></div><div></div></div><p>This example deploys a simple Stateless Session Bean that is used as a proxy to send and receive JMS messages in a managed environment.
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
         Receiving a JMS message from inside an EJB (or MBean or servlet) method is considered an anti-pattern since it will require the creation
         of a new JMS consumer on every send - even when using the JCA adaptor. This is likely to make it very slow. (Users of the Spring JMSTemplate be warned that this is what it uses
         to implement it's receive.)
         If you want to receive messages as part of a global transaction then use an MDB instead.
      </div><pre class="programlisting">
public class StatelessSessionExampleBean implements SessionBean
{

   private ConnectionFactory cf = null;

   public void drain(String queueName) throws Exception
   {
      InitialContext ic = new InitialContext();
      Queue queue = (Queue)ic.lookup(queueName);
      ic.close();

      Session session = null;
      Connection conn = null;

      try
      {
         conn = getConnection();
         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
         MessageConsumer consumer = session.createConsumer(queue);
         Message m = null;
         do
         {
            m = consumer.receiveNoWait();
         }
         while(m != null);
      }
      finally
      {
         if (conn != null)
         {
            closeConnection(conn);
         }
      }
   }

   public void send(String txt, String queueName) throws Exception
   {
      InitialContext ic = new InitialContext();

      Queue queue = (Queue)ic.lookup(queueName);

      ic.close();

      Session session = null;
      Connection conn = null;

      try
      {
         conn = getConnection();

         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         MessageProducer producer = session.createProducer(queue);

         TextMessage tm = session.createTextMessage(txt);

         producer.send(tm);

         System.out.println("message " + txt + " sent to " + queueName);
      }
      finally
      {
         if (conn != null)
         {
            closeConnection(conn);
         }
      }
   }

   public int browse(String queueName) throws Exception
   {
      InitialContext ic = new InitialContext();
      Queue queue = (Queue)ic.lookup(queueName);
      ic.close();

      Session session = null;
      Connection conn = null;

      try
      {
         conn = getConnection();
         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
         QueueBrowser browser = session.createBrowser(queue);

         ArrayList list = new ArrayList();
         for(Enumeration e = browser.getEnumeration(); e.hasMoreElements(); )
         {
            list.add(e.nextElement());
         }

         return list.size();
      }
      finally
      {
         if (conn != null)
         {
            closeConnection(conn);
         }
      }
   }

   public String receive(String queueName) throws Exception
   {
      InitialContext ic = new InitialContext();
      Queue queue = (Queue)ic.lookup(queueName);
      ic.close();

      Session session = null;
      Connection conn = null;

      // WARN! this is an anti-pattern - please see above warning

      try
      {
         conn = getConnection();
         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         MessageConsumer consumer = session.createConsumer(queue);

         System.out.println("blocking to receive message from queue " + queueName + " ...");
         TextMessage tm = (TextMessage)consumer.receive(5000);

         if (tm == null)
         {
            throw new Exception("No message!");
         }

         System.out.println("Message " + tm.getText() + " received");

         return tm.getText();
      }
      finally
      {
         if (conn != null)
         {
            closeConnection(conn);
         }
      }
   }

   public Connection getConnection() throws Exception
   {

      Connection connection = null;

      try
      {
         connection = cf.createConnection();

         connection.start();
      }
      catch(Exception e )
      {
         if(connection != null)
         {
            closeConnection(connection);
         }
         System.out.println("Failed to get connection...exception is " + e);
         throw e;
      }

      return connection;
   }

   public void closeConnection(Connection con) throws Exception
   {
      try
      {
         con.close();
      }
      catch(JMSException jmse)
      {
         System.out.println("Could not close connection " + con +" exception was " + jmse);
         throw jmse;
      }
   }

   public void setSessionContext(SessionContext ctx) throws EJBException, RemoteException
   {
   }

   public void ejbCreate()
   {
      try
      {
         InitialContext ic = new InitialContext();

         cf = (ConnectionFactory)ic.lookup("java:/JmsXA");

         ic.close();
      }
      catch(Exception e)
      {
         e.printStackTrace();
         throw new EJBException("Initalization failure: " + e.getMessage());
      }
   }

   public void ejbRemove() throws EJBException
   {
      try
      {
         if(cf != null)
         {
            cf = null;
         }
      }
      catch(Exception e)
      {
         throw new EJBException("ejbRemove ", e);
      }
   }

   public void ejbActivate() throws EJBException, RemoteException
   {
   }

   public void ejbPassivate() throws EJBException, RemoteException
   {
   }

}
    </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples.mdb.ejb21"></a>7.4.&nbsp;Using EJB2.1 Message Driven Beans</h2></div></div><div></div></div><p>This example deploys a simple Message Driven Bean that processes messages sent to a test queue.  Once it receives a message and "processes" it, the MDB sends an acknowledgment message to a temporary destination created by the sender for this purpose. The example is considered successful if the sender receives the acknowledgment message.
    </p><p>The MDB ejb-jar.xml descriptor
    </p><pre class="programlisting">
&lt;ejb-jar&gt;
  &lt;enterprise-beans&gt;
    &lt;message-driven&gt;
      &lt;ejb-name&gt;MDBExample&lt;/ejb-name&gt;
      &lt;ejb-class&gt;org.jboss.example.jms.mdb.MDBExample&lt;/ejb-class&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
    &lt;/message-driven&gt;
  &lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;
    </pre><p>The MDB jboss.xml descriptor
   </p><pre class="programlisting">
&lt;enterprise-beans&gt;
  &lt;message-driven&gt;
    &lt;ejb-name&gt;MDBExample&lt;/ejb-name&gt;
    &lt;destination-jndi-name&gt;queue/@QUEUE_NAME@&lt;/destination-jndi-name&gt;
  &lt;/message-driven&gt;
&lt;/enterprise-beans&gt;
    </pre><pre class="programlisting">
public class MDBExample implements MessageDrivenBean, MessageListener
{
   private MessageDrivenContext ctx;

   private ConnectionFactory cf = null;

   public void onMessage(Message m)
   {
      Session session = null;
      Connection conn = null;

      try
      {
         TextMessage tm = (TextMessage)m;

         String text = tm.getText();
         System.out.println("message " + text + " received");
         String result = process(text);
         System.out.println("message processed, result: " + result);

         conn = getConnection();
         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         Destination replyTo = m.getJMSReplyTo();
         MessageProducer producer = session.createProducer(replyTo);
         TextMessage reply = session.createTextMessage(result);

         producer.send(reply);
         producer.close();

      }
      catch(Exception e)
      {
         ctx.setRollbackOnly();
         e.printStackTrace();
         System.out.println("The Message Driven Bean failed!");
      }
      finally
      {
         if (conn != null)
         {
            try
            {
               closeConnection(conn);
            }
            catch(Exception e)
            {
               System.out.println("Could not close the connection!" +e);
            }
         }
      }
   }

   private String process(String s)
   {
      // flip the string

      String result = "";

      for (int i = 0; i &lt; text.length(); i++)
      {
         result = text.charAt(i) + result;
      }
      return result;
   }

   public Connection getConnection() throws Exception
   {
      Connection connection = null;

      try
      {
         connection = cf.createConnection();
         connection.start();
      }
      catch(Exception e )
      {
         if(connection != null)
         {
            closeConnection(connection);
         }
         System.out.println("Failed to get connection...exception is " + e);
         throw e;
      }

      return connection;
   }

   public void closeConnection(Connection con) throws Exception
   {
      try
      {
         con.close();
      }
      catch(JMSException e)
      {
         System.out.println("Could not close connection " + con + " exception was " + e);
      }
   }

   public void ejbCreate()
   {
      try
      {
         InitialContext ic = new InitialContext();

         cf = (ConnectionFactory)ic.lookup("java:/JmsXA");

         ic.close();
      }
      catch(Exception e)
      {
         e.printStackTrace();
         throw new EJBException("Failure to get connection factory: " + e.getMessage());
      }
   }

   public void ejbRemove() throws EJBException
   {
      try
      {
         if(cf != null)
         {
            cf = null;
         }
      }
      catch(Exception e)
      {
         throw new EJBException("ejbRemove", e);
      }
   }

   public void setMessageDrivenContext(MessageDrivenContext ctx)
   {
      this.ctx = ctx;
   }


}

   </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples.mdb.ejb3"></a>7.5.&nbsp;Using EJB3 Message Driven Beans</h2></div></div><div></div></div><p>
         This example deploys a simple EJB3 Message Driven Bean that processes messages sent to a
         test queue.  Once it receives a message and "processes" it, the MDB sends an
         acknowledgment message to a temporary destination created by the sender for this purpose.
         The example is considered successful if the sender receives the acknowledgment message.
      </p><p>
         This example relies on having access to a running JBoss Messaging instance.
         The JBoss Messaging instance must be installed and started according to the
         "Installation" chapter of this document. The example will automatically deploy
         its own queue, unless a queue with the same name is already deployed.
      </p><p>
         This example also relies on having access to the
         <tt class="filename">jboss-messaging-client.jar</tt> archive that comes with the release bundle.
         If you run this example from an unzipped installation bundle, the example run script
         is correctly configured to find the client jar. Otherwise, you must modify example's
         <tt class="filename">build.xml</tt> accordingly.
      </p><p>
         The example was designed to deploy its server-side artifacts under a JBoss'
         <tt class="literal">messaging</tt> configuration. If you intend to use the script with
         a JBoss configuration that is named differently, please modify the example's
         <tt class="filename">build.xml</tt> accordingly.
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
         The JBoss instance that runs the Messaging server must also have EJB3 support
         previously installed. If the EJB3 support is not installed, the example will fail
         with an error message similar to:

         <pre class="programlisting">
C:\work\src\cvs\jboss-head\jms\docs\examples\ejb3mdb\build.xml:60: EJB3 does not seem
to be installed in C:\work\src\jboss-4.0.3-src\build\output\jboss-4.0.3/server/messaging!
Install it and try again.
         </pre><p>
            For instructions on how to install EJB3 support,
            please go to <a href="http://docs.jboss.org/ejb3" target="_top">JBoss EJB3 documentation page</a>
            or use the JBoss Installer.
         </p></div><p>
         The EJB3 Message Driven Bean source code:
      </p><pre class="programlisting">
@MessageDriven(activationConfig =
{
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/testQueue"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="10")
})
public class EJB3MDBExample implements MessageListener
{
   public void onMessage(Message m)
   {
      businessLogic(m);
   }

   private void businessLogic(Message m)
   {
      Connection conn = null;
      Session session = null;

      try
      {
         TextMessage tm = (TextMessage)m;

         String text = tm.getText();
         System.out.println("message " + text + " received");

         // flip the string
         String result = "";
         for(int i = 0; i &lt; text.length(); i++)
         {
            result = text.charAt(i) + result;
         }

         System.out.println("message processed, result: " + result);


         InitialContext ic = new InitialContext();
         ConnectionFactory cf = (ConnectionFactory)ic.lookup("java:/JmsXA");
         ic.close();

         conn = cf.createConnection();
         conn.start();
         session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         Destination replyTo = m.getJMSReplyTo();
         MessageProducer producer = session.createProducer(replyTo);
         TextMessage reply = session.createTextMessage(result);

         producer.send(reply);
         producer.close();

      }
      catch(Exception e)
      {
         e.printStackTrace();
         System.out.println("The Message Driven Bean failed!");
      }
      finally
      {
         if (conn != null)
         {
            try
            {
               conn.close();
            }
            catch(Exception e)
            {
               System.out.println("Could not close the connection!" +e);
            }
         }
      }
   }
}
     </pre><p>The basic test examples in this chapter serve as the sanity check for your JBoss Messaging installation. They also provide basic programming examples. To develop your own JMS services, you probably need to configure JBoss Messaging to setup your own destinations and connection factories etc. In <a href="#configuration" title="Chapter&nbsp;8.&nbsp;Configuration">Chapter&nbsp;8, <i>Configuration</i></a>, we will discuss JBoss Messaging configuration files and options.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;8.&nbsp;Configuration</h2></div></div><div></div></div><p>
      The JMS API specifies how a messaging client interacts with a messaging server. The exact
      definition and implementation of messaging services, such as message destinations and
      connection factories, are specific to JMS providers. JBoss Messaging has its own
      configuration files to configure services. If you are migrating services from JBossMQ
      (or other JMS provider) to JBoss Messaging, you will need to understand those
      configuration files.
  </p><p>
      In this chapter, we discuss how to configure various services inside JBoss Messaging,
      which work together to provide JMS API level services to client applications.
  </p><p>
      Starting with the JBoss Messaging 1.0.1 release, the service configuration is spread among
      several configuration files (the 1.0.0 release used to have all configuration information
      lumped together in the SAR's deployment descriptor
      <tt class="filename">jboss-messaging.sar/META-INF/jboss-service.xml</tt>).
      Depending on the functionality provided by the services it configures, the configuration
      data is distributed between
      <tt class="filename">messaging-service.xml</tt>,
      <tt class="filename">remoting-service.xml</tt>,
      <tt class="filename">xxx-persistence-service.xml</tt>
       (or <tt class="filename">clustered-xxx-persistence-service.xml</tt> for a clustered configuration,
       more about clusterered configuration in <a href="#c_configuration" title="Chapter&nbsp;9.&nbsp;JBoss Messaging Clustering Configuration">Chapter&nbsp;9, <i>JBoss Messaging Clustering Configuration</i></a>),
      <tt class="filename">connection-factories-service.xml</tt> and
      <tt class="filename">destinations-service.xml</tt>.
   </p><p>
      The AOP client-side and server-side interceptor stacks are configured in
      <tt class="filename">aop-messaging-client.xml</tt> and <tt class="filename">aop-messaging-server.xml</tt>.
      Normally you will not want to change them, but you can some of the interceptors can be removed
      to give a small performance increase, if you don't need them. Be very careful you have considered the security implications before removing the
      security interceptor.
   </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.serverpeer"></a>8.1.&nbsp;Configuring the ServerPeer</h2></div></div><div></div></div><p>
       The Server Peer is the "heart" of the JBoss Messaging JMS facade. The server's configuration,
       resides in <tt class="filename">messaging-service.xml</tt> configuration file.
    </p><p>All JBoss Messaging services are rooted at the server peer</p><p>An example of a Server Peer configuration is presented below. Note that not all values for the server peer's attributes are
     specified in the example</p><pre class="programlisting">
 &lt;mbean code="org.jboss.jms.server.ServerPeer"
        name="jboss.messaging:service=ServerPeer"
        xmbean-dd="xmdesc/ServerPeer-xmbean.xml"&gt;

   &lt;constructor&gt;
     &lt;!-- ServerPeerID --&gt;
     &lt;arg type="int" value="0"/&gt;
     &lt;!-- DefaultQueueJNDIContext --&gt;
     &lt;arg type="java.lang.String" value="/queue"/&gt;
     &lt;!-- DefaultTopicJNDIContext --&gt;
     &lt;arg type="java.lang.String" value="/topic"/&gt;
   &lt;/constructor&gt;

   &lt;attribute name="PostOffice"&gt;jboss.messaging:service=PostOffice&lt;/attribute&gt;
   &lt;attribute name="SecurityDomain"&gt;java:/jaas/messaging&lt;/attribute&gt;
   &lt;attribute name="DefaultSecurityConfig"&gt;
      &lt;security&gt;
        &lt;role name="guest" read="true" write="true" create="true"/&gt;
      &lt;/security&gt;
   &lt;/attribute&gt;
   &lt;attribute name="DefaultDLQ"&gt;
       jboss.messaging.destination:service=Queue,name=DLQ&lt;/attribute&gt;
   &lt;attribute name="DefaultMaxDeliveryAttempts"&gt;10&lt;/attribute&gt;
   &lt;attribute name="DefaultExpiryQueue"&gt;
       jboss.messaging.destination:service=Queue,name=ExpiryQueue&lt;/attribute&gt;
   &lt;attribute name="DefaultRedeliveryDelay"&gt;0&lt;/attribute&gt;
   &lt;attribute name="QueueStatsSamplePeriod"&gt;5000&lt;/attribute&gt;
   &lt;attribute name="FailoverStartTimeout"&gt;60000&lt;/attribute&gt;
   &lt;attribute name="FailoverCompleteTimeout"&gt;300000&lt;/attribute&gt;
   &lt;attribute name="DefaultMessageCounterHistoryDayLimit"&gt;-1&lt;/attribute&gt;

   &lt;depends optional-attribute-name="PersistenceManager"&gt;
       jboss.messaging:service=PersistenceManager&lt;/depends&gt;
   &lt;depends optional-attribute-name="JMSUserManager"&gt;
       jboss.messaging:service=JMSUserManager&lt;/depends&gt;
   &lt;depends&gt;jboss.messaging:service=Connector,transport=bisocket&lt;/depends&gt;

 &lt;/mbean&gt;
     </pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.serverpeer.attributes"></a>8.1.1.&nbsp;
             We now discuss the MBean attributes of the ServerPeer MBean
        </h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.persistencemanager"></a>8.1.1.1.&nbsp;PersistenceManager</h4></div></div><div></div></div><p>
              This is the persistence manager that the ServerPeer uses. You will not normally need to change this attribute.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.postoffice"></a>8.1.1.2.&nbsp;PostOffice</h4></div></div><div></div></div><p>
              This is the post office that the ServerPeer uses. You will not normally need to change this attribute.
              The post office is responsible for routing messages to queues and maintaining the mapping between addresses and queues.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.jmsusermanager"></a>8.1.1.3.&nbsp;JMSUserManager</h4></div></div><div></div></div><p>
              This is the JMS user manager that the ServerPeer uses. You will not normally need to change this attribute.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultdlq"></a>8.1.1.4.&nbsp;DefaultDLQ</h4></div></div><div></div></div><p>
              This is the name of the default DLQ (Dead Letter Queue) the server peer will use for destinations. The DLQ can be overridden on a per
              destination basis - see the destination MBean configuration for more details.

              A DLQ is a special destination where messages are sent when the server has attempted to deliver them unsuccessfully more than a certain number of
              times.

              If the DLQ is not specified at all then the message will be removed after the maximum number of delivery attempts.

              The maximum number of delivery attempts can be specified using the attribute DefaultMaxDeliveryAttempts for a global default or individually
              on a per destination basis.

           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultexpiryqueue"></a>8.1.1.5.&nbsp;DefaultExpiryQueue</h4></div></div><div></div></div><p>
              This is the name of the default expiry queue the server peer will use for destinations. The expiry can be overridden on a per
              destination basis - see the destination MBean configuration for more details.

              An expiry queue is a special destination where messages are sent when they have expired. Message expiry is determined by the value of
              Message::getJMSExpiration()

              If the expiry queue is not specified at all then the message will be removed after it is expired.

           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.serverpeerid"></a>8.1.1.6.&nbsp;ServerPeerID</h4></div></div><div></div></div><p>
              The unique id of the server. In a cluster each server MUST have a unique id.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultqueuejndicontext"></a>8.1.1.7.&nbsp;DefaultQueueJNDIContext</h4></div></div><div></div></div><p>
              The default JNDI context to use when binding queues. Defaults to /queue.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultopicjndicontext"></a>8.1.1.8.&nbsp;DefaultTopicJNDIContext</h4></div></div><div></div></div><p>
              The default JNDI context to use when binding topics. Defaults to /topic.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.destinations"></a>8.1.1.9.&nbsp;Destinations</h4></div></div><div></div></div><p>
              Returns a list of the destinations (queues and topics) currently deployed.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultmaxdeliveryattempts"></a>8.1.1.10.&nbsp;DefaultMaxDeliveryAttempts</h4></div></div><div></div></div><p>
              The default for the maximum number of times delivery of a message will be attempted before sending the message to the DLQ, if configured.
           </p><p>
              The default value is <tt class="literal">10</tt>
           </p><p>This value can also be overridden on a per destination basis</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.failoverstarttimeout"></a>8.1.1.11.&nbsp;FailoverStartTimeout</h4></div></div><div></div></div><p>
              The maximum number of milliseconds the client will wait for failover to start on the server side when a problem is detected.
           </p><p>
              The default value is <tt class="literal">60000</tt> (one minute)
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.failovercompletetimeout"></a>8.1.1.12.&nbsp;FailoverCompleteTimeout</h4></div></div><div></div></div><p>
              The maximum number of milliseconds the client will wait for failover to complete on the server side after it has started.
           </p><p>
              The default value is <tt class="literal">300000</tt> (five minutes)
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultredliverydelay"></a>8.1.1.13.&nbsp;DefaultRedeliveryDelay</h4></div></div><div></div></div><p>
              When redelivering a message after failure of previous delivery it is often beneficial to introduce a delay perform redelivery in order
              to prevent thrashing of delivery-failure, delivery-failure etc
           </p><p>
              The default value is <tt class="literal">0</tt> which means there will be no delay.
           </p><p>Change this if your application could benefit with a delay before redelivery. This value can also be overridden on a per destination basis</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.queuestatssampleperiod"></a>8.1.1.14.&nbsp;QueueStatsSamplePeriod</h4></div></div><div></div></div><p>
              Periodically the server will query each queue to gets its message statistics. This is the period.
           </p><p>
              The default value is <tt class="literal">10000</tt> milliseconds
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultmessagecounterhistorydaylimit"></a>8.1.1.15.&nbsp;DefaultMessageCounterHistoryDayLimit</h4></div></div><div></div></div><p>
                 JBoss Messaging provides a message counter history which shows the number of messages arriving on each queue of a certain number of
                 days. This attribute represents the maxiumum number of days for which to store message counter history. It can be overridden on a per
                 destination basis
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.messagecounters"></a>8.1.1.16.&nbsp;MessageCounters</h4></div></div><div></div></div><p>
                 JBoss Messaging provides a message counter for each queue.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.messagecounterstatistics"></a>8.1.1.17.&nbsp;MessageCountersStatistics</h4></div></div><div></div></div><p>
                 JBoss Messaging provides statistics for each message counter for each queue.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.attributes.defaultsecurity"></a>8.1.1.18.&nbsp;DefaultSecurityConfig</h4></div></div><div></div></div><p>
              Default security configuration is used when the security configuration for a specific
              queue or topic has not been overridden in the destination's deployment descriptor.
              It has exactly the same syntax and semantics as in JBossMQ.
           </p><p>
              The <tt class="literal">DefaultSecurityConfig</tt> attribute element should contain
              one <tt class="literal">&lt;security&gt;</tt> element.
              The <tt class="literal">&lt;security&gt;</tt> element can contain multiple
              <tt class="literal">&lt;role&gt;</tt> elements. Each <tt class="literal">&lt;role&gt;</tt>
              element defines the default access for that particular role.
           </p><p>
              If the <tt class="literal">read</tt> attribute is <tt class="literal">true</tt> then that role
              will be able to read (create consumers, receive messaages or browse) destinations
              by default.
           </p><p>
              If the <tt class="literal">write</tt> attribute is <tt class="literal">true</tt> then that role
              will be able to write (create producers or send messages) to destinations by default.
           </p><p>
              If the <tt class="literal">create</tt> attribute is <tt class="literal">true</tt> then that role
              will be able to create durable subscriptions on topics by default.
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.serverpeer.operations"></a>8.1.2.&nbsp;
             We now discuss the MBean operations of the ServerPeer MBean
        </h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.deployQueue"></a>8.1.2.1.&nbsp;DeployQueue</h4></div></div><div></div></div><p>
              This operation lets you programmatically deploy a queue.
           </p><p>There are two overloaded versions of this operation</p><p>If the queue already exists but is undeployed it is deployed. Otherwise it is created and deployed</p><p>The <tt class="literal">name</tt> parameter represents the name of the destination to deploy.</p><p>The <tt class="literal">jndiName</tt> parameter (optional) represents the full jndi name where to bind the destination. If this is not specified
           then the destination will be bound in &lt;DefaultQueueJNDIContext&gt;/&lt;name&gt;</p><p>The first version of this operation deploys the destination with the default paging parameters. The second overloaded version deploys
           the destination with the specified paging parameters. See the section on configuring destinations for a discussion of what the
           paging parameters mean</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.undeployQueue"></a>8.1.2.2.&nbsp;UndeployQueue</h4></div></div><div></div></div><p>
              This operation lets you programmatically undeploy a queue.
           </p><p>The queue is undeployed but is NOT removed from persistent storage.</p><p>This operation returns <tt class="literal">true</tt> if the queue was successfull undeployed. otherwise it returns <tt class="literal">false</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.destroyQueue"></a>8.1.2.3.&nbsp;DestroyQueue</h4></div></div><div></div></div><p>
              This operation lets you programmatically destroy a queue.
           </p><p>The queue is undeployed and then all its data is destroyed from the database</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Be careful when using this method since it will delete all data for the queue</div><p>This operation returns <tt class="literal">true</tt> if the queue was successfully destroyed. otherwise it returns <tt class="literal">false</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.deployTopic"></a>8.1.2.4.&nbsp;DeployTopic</h4></div></div><div></div></div><p>
              This operation lets you programmatically deploy a topic.
           </p><p>There are two overloaded versions of this operation</p><p>If the topic already exists but is undeployed it is deployed. Otherwise it is created and deployed</p><p>The <tt class="literal">name</tt> parameter represents the name of the destination to deploy.</p><p>The <tt class="literal">jndiName</tt> parameter (optional) represents the full jndi name where to bind the destination. If this is not specified
           then the destination will be bound in &lt;DefaultTopicJNDIContext&gt;/&lt;name&gt;</p><p>The first version of this operation deploys the destination with the default paging parameters. The second overloaded version deploys
           the destination with the specified paging parameters. See the section on configuring destinations for a discussion of what the
           paging parameters mean</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.undeployTopic"></a>8.1.2.5.&nbsp;UndeployTopic</h4></div></div><div></div></div><p>
              This operation lets you programmatically undeploy a topic.
           </p><p>The queue is undeployed but is NOT removed from persistent storage.</p><p>This operation returns <tt class="literal">true</tt> if the topic was successfully undeployed. otherwise it returns <tt class="literal">false</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.destroyTopic"></a>8.1.2.6.&nbsp;DestroyTopic</h4></div></div><div></div></div><p>
              This operation lets you programmatically destroy a topic.
           </p><p>The topic is undeployed and then all its data is destroyed from the database</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Be careful when using this method since it will delete all data for the topic</div><p>This operation returns <tt class="literal">true</tt> if the topic was successfully destroyed. otherwise it returns <tt class="literal">false</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.listmessagecountersashtml"></a>8.1.2.7.&nbsp;ListMessageCountersHTML</h4></div></div><div></div></div><p>
              This operation returns message counters in an easy to display HTML format.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.resetallmessagecounters"></a>8.1.2.8.&nbsp;ResetAllMesageCounters</h4></div></div><div></div></div><p>
              This operation resets all message counters to zero.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.resetallmessagecounterhistories"></a>8.1.2.9.&nbsp;ResetAllMesageCounters</h4></div></div><div></div></div><p>
              This operation resets all message counter histories to zero.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.enablemessagecounters"></a>8.1.2.10.&nbsp;EnableMessageCounters</h4></div></div><div></div></div><p>
              This operation enables all message counters for all destinations. Message counters are disabled by default.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.disablemessagecounters"></a>8.1.2.11.&nbsp;DisableMessageCounters</h4></div></div><div></div></div><p>
              This operation disables all message counters for all destinations. Message counters are disabled by default.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.retrievepreparedtransactions"></a>8.1.2.12.&nbsp;RetrievePreparedTransactions</h4></div></div><div></div></div><p>
              Retrieves a list of the Xids for all transactions currently in a prepared state on the node.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.serverpeer.operations.showpreparedtransactions"></a>8.1.2.13.&nbsp;ShowPreparedTransactions</h4></div></div><div></div></div><p>
              Retrieves a list of the Xids for all transactions currently in a prepared state on the node in an easy to display HTML format.
           </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.changingds"></a>8.2.&nbsp;Changing the Database</h2></div></div><div></div></div><p>
               Several JBoss Messaging services interact with persistent storage. They include: The Persistence Manager,
               The PostOffice and the JMS User Manager.
               The Persistence Manager is used to handle the message-related persistence.
               The Post Office handles binding related persistence.
               The JMS User manager handles user related persistence
               The configuration for all these MBeans is handled in the <tt class="filename">xxx-persistence-service.xml</tt> file
        </p><p>
           If the database you want to switch to is one of MySQL, Oracle, PostgreSQL, MS SQL Sever or Sybase,
           persistence configuration files are already available in
           the <tt class="filename">examples/config</tt> directory of the release bundle.
        </p><p>
           In order to enable support for one of these databases, just replace the default
           <tt class="filename">hsqldb-persistence-service.xml</tt> configuration file with the
           database-specific configuration file and restart the server.
        </p><p>
           Also, be aware that by default, the Messaging services relying on a datastore
           are referencing <tt class="literal">"java:/DefaultDS"</tt> for the datasource.
           If you are deploying a datasource with a different JNDI name, you need to update
           all the <tt class="literal">DataSource</tt> attribute in the persistence configuration file.

           Example data source configurations for each of the popular databases are available in the distribution.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.postoffice"></a>8.3.&nbsp;Configuring the Post office</h2></div></div><div></div></div><p>It is the job of the post office to route messages to their destination(s).
    </p><p>The post office maintains the mappings between addresses to which messages can be sent and their final queues.</p><p>For example when sending a message with an address that represents a JMS queue name, the post office will route this to a single
    queue - the JMS queue. When sending a message with an address that repesents a JMS topic name, the post office will route this to a set of
    queues - one for each JMS subscription.</p><p>The post office also handles the persistence for the mapping of addresses</p><p>JBoss Messaging comes with two different post office implementations - depending on whether you want clustering or not. The clustered post office
    has the ability to route messages to other nodes in the cluster</p><p>Whether you use the clustered post office or not depends on whether you deploy the <tt class="literal">clustered-xxx-persistence-service.xml</tt> MBean config
    or just the non clustered <tt class="literal">xxx-persistence-service.xml</tt> file.</p><p>It is likely that in future releases of JBoss Messaging the clustered and non clustered post offices will be combined into a single post office for
    ease of configuration</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.postoffice.nonclustered"></a>8.3.1.&nbsp;Non clustered post office</h3></div></div><div></div></div><p>The non clustered post office should be used where clustering is not required. It will be used when the
       non clustered <tt class="literal">xxx-persistence-service.xml</tt> file is deployed.</p><p>Here is an example of a non clustered post office configuration:</p><pre class="programlisting">

&lt;mbean code="org.jboss.messaging.core.plugin.DefaultPostOfficeService"
      name="jboss.messaging:service=PostOffice"
      xmbean-dd="xmdesc/DefaultPostOffice-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;attribute name="PostOfficeName"&gt;JMS&lt;/attribute&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
      &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
CREATE_POSTOFFICE_TABLE=CREATE TABLE JBM_POSTOFFICE (POSTOFFICE_NAME VARCHAR(255), NODE_ID INTEGER, QUEUE_NAME VARCHAR(1023), COND VARCHAR(1023), SELECTOR VARCHAR(1023), CHANNEL_ID BIGINT, CLUSTERED CHAR(1))
INSERT_BINDING=INSERT INTO JBM_POSTOFFICE (POSTOFFICE_NAME, NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED) VALUES (?, ?, ?, ?, ?, ?, ?)
DELETE_BINDING=DELETE FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME=? AND NODE_ID=? AND QUEUE_NAME=?
LOAD_BINDINGS=SELECT NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME  = ?
      ]]&gt;&lt;/attribute&gt;
   &lt;/mbean&gt;

       </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.postoffice.nonclustered.attributes"></a>8.3.1.1.&nbsp;The non clustered post office has the following attributes</h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.nonclustered.attributes.datasource"></a>8.3.1.1.1.&nbsp;DataSource</h5></div></div><div></div></div><p>The datasource the postoffice should use for persisting its mapping data</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.nonclustered.attributes.sqlproperties"></a>8.3.1.1.2.&nbsp;SQLProperties</h5></div></div><div></div></div><p>
                            This is where the DDL and DML for the particular database is specified.
                            If a particular DDL or DML statement is not overridden, the default Hypersonic
                            configuration will be used for that statement.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.nonclustered.attributes.createtables"></a>8.3.1.1.3.&nbsp;CreateTablesOnStartup</h5></div></div><div></div></div><p>
                  Set this to <tt class="literal">true</tt> if you wish the post office to attempt
                  to create the tables (and indexes) when it starts. If the tables (or indexes)
                  already exist a <tt class="literal">SQLException</tt> will be thrown by the JDBC driver and
                  ignored by the Persistence Manager, allowing it to continue.
               </p><p>
                  By default the value of <tt class="literal">CreateTablesOnStartup</tt> attribute
                  is set to <tt class="literal">true</tt>
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.nonclustered.attributes.postofficename"></a>8.3.1.1.4.&nbsp;PostOfficeName</h5></div></div><div></div></div><p>
                  The name of the post office
               </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.postoffice.clustered"></a>8.3.2.&nbsp;Clustered post office</h3></div></div><div></div></div><p>The clustered post office should be used where clustering is required. It will be used when the
       clustered <tt class="literal">clustered-xxx-persistence-service.xml</tt> file is deployed.</p><p>Here is an example of a clustered post office configuration:</p><pre class="programlisting">

&lt;mbean code="org.jboss.messaging.core.plugin.ClusteredPostOfficeService"
      name="jboss.messaging:service=PostOffice"
      xmbean-dd="xmdesc/ClusteredPostOffice-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;attribute name="PostOfficeName"&gt;Clustered JMS&lt;/attribute&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
      &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
CREATE_POSTOFFICE_TABLE=CREATE TABLE JBM_POSTOFFICE (POSTOFFICE_NAME VARCHAR(255), NODE_ID INTEGER, QUEUE_NAME VARCHAR(1023), COND VARCHAR(1023), SELECTOR VARCHAR(1023), CHANNEL_ID BIGINT, CLUSTERED CHAR(1))
INSERT_BINDING=INSERT INTO JBM_POSTOFFICE (POSTOFFICE_NAME, NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED) VALUES (?, ?, ?, ?, ?, ?, ?)
DELETE_BINDING=DELETE FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME=? AND NODE_ID=? AND QUEUE_NAME=?
LOAD_BINDINGS=SELECT NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME  = ?
      ]]&gt;&lt;/attribute&gt;
      &lt;attribute name="GroupName"&gt;DefaultPostOffice&lt;/attribute&gt;
      &lt;attribute name="StateTimeout"&gt;5000&lt;/attribute&gt;
      &lt;attribute name="CastTimeout"&gt;5000&lt;/attribute&gt;
      &lt;attribute name="StatsSendPeriod"&gt;10000&lt;/attribute&gt;
      &lt;attribute name="MessagePullPolicy"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.NullMessagePullPolicy&lt;/attribute&gt;
      &lt;attribute name="ClusterRouterFactory"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.DefaultRouterFactory&lt;/attribute&gt;


      &lt;attribute name="ChannelFactoryName"&gt;jgroups.mux:name=Multiplexer&lt;/attribute&gt;
      &lt;attribute name="SyncChannelName"&gt;udp-sync&lt;/attribute&gt;
      &lt;attribute name="AsyncChannelName"&gt;udp&lt;/attribute&gt;
      &lt;attribute name="ChannelPartitionName"&gt;${jboss.partition.name:DefaultPartition}-JMS&lt;/attribute&gt;

      &lt;attribute name="AsyncChannelConfig"&gt;
         &lt;config&gt;
            &lt;UDP mcast_recv_buf_size="500000" down_thread="false" ip_mcast="true" mcast_send_buf_size="32000"
           mcast_port="45567" ucast_recv_buf_size="500000" use_incoming_packet_handler="false"
           mcast_addr="228.8.8.8" use_outgoing_packet_handler="true" loopback="true" ucast_send_buf_size="32000" ip_ttl="32" bind_addr="127.0.0.1"/&gt;
            &lt;AUTOCONF down_thread="false" up_thread="false"/&gt;
            &lt;PING timeout="2000" down_thread="false" num_initial_members="3" up_thread="false"/&gt;
            &lt;MERGE2 max_interval="10000" down_thread="false" min_interval="5000" up_thread="false"/&gt;
            &lt;FD_SOCK down_thread="false" up_thread="false"/&gt;
            &lt;FD timeout="20000" max_tries="3" down_thread="false" up_thread="false" shun="true"/&gt;
            &lt;VERIFY_SUSPECT timeout="1500" down_thread="false" up_thread="false"/&gt;
            &lt;pbcast.NAKACK max_xmit_size="8192" down_thread="false" use_mcast_xmit="true" gc_lag="50" up_thread="false"
                         retransmit_timeout="100,200,600,1200,2400,4800"/&gt;
            &lt;UNICAST timeout="1200,2400,3600" down_thread="false" up_thread="false"/&gt;
            &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="20000" down_thread="false" max_bytes="0" up_thread="false"/&gt;
            &lt;FRAG frag_size="8192" down_thread="false" up_thread="false"/&gt;
            &lt;VIEW_SYNC avg_send_interval="60000" down_thread="false" up_thread="false" /&gt;
            &lt;pbcast.GMS print_local_addr="true" join_timeout="3000" down_thread="false" join_retry_timeout="2000" up_thread="false" shun="true"/&gt;
         &lt;/config&gt;
      &lt;/attribute&gt;

      &lt;attribute name="SyncChannelConfig"&gt;
         &lt;config&gt;
            &lt;UDP mcast_recv_buf_size="500000" down_thread="false" ip_mcast="true" mcast_send_buf_size="32000"
           mcast_port="45568" ucast_recv_buf_size="500000" use_incoming_packet_handler="false"
           mcast_addr="228.8.8.8" use_outgoing_packet_handler="true" loopback="true" ucast_send_buf_size="32000" ip_ttl="32" bind_addr="127.0.0.1"/&gt;
            &lt;AUTOCONF down_thread="false" up_thread="false"/&gt;
            &lt;PING timeout="2000" down_thread="false" num_initial_members="3" up_thread="false"/&gt;
            &lt;MERGE2 max_interval="10000" down_thread="false" min_interval="5000" up_thread="false"/&gt;
            &lt;FD_SOCK down_thread="false" up_thread="false"/&gt;
            &lt;FD timeout="20000" max_tries="3" down_thread="false" up_thread="false" shun="true"/&gt;
            &lt;VERIFY_SUSPECT timeout="1500" down_thread="false" up_thread="false"/&gt;
            &lt;pbcast.NAKACK max_xmit_size="8192" down_thread="false" use_mcast_xmit="true" gc_lag="50" up_thread="false"
                         retransmit_timeout="100,200,600,1200,2400,4800"/&gt;
            &lt;UNICAST timeout="1200,2400,3600" down_thread="false" up_thread="false"/&gt;
            &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="20000" down_thread="false" max_bytes="0" up_thread="false"/&gt;
            &lt;FRAG frag_size="8192" down_thread="false" up_thread="false"/&gt;
            &lt;VIEW_SYNC avg_send_interval="60000" down_thread="false" up_thread="false" /&gt;
            &lt;pbcast.GMS print_local_addr="true" join_timeout="3000" down_thread="false" join_retry_timeout="2000" up_thread="false" shun="true"/&gt;
            &lt;pbcast.STATE_TRANSFER down_thread="false" up_thread="false"/&gt;
         &lt;/config&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;

       </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.postoffice.clustered.attributes"></a>8.3.2.1.&nbsp;The nclustered post office has the following attributes</h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.datasource"></a>8.3.2.1.1.&nbsp;DataSource</h5></div></div><div></div></div><p>The datasource the postoffice should use for persisting its mapping data</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.sqlproperties"></a>8.3.2.1.2.&nbsp;SQLProperties</h5></div></div><div></div></div><p>
                            This is where the DDL and DML for the particular database is specified.
                            If a particular DDL or DML statement is not overridden, the default Hypersonic
                            configuration will be used for that statement.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.createtables"></a>8.3.2.1.3.&nbsp;CreateTablesOnStartup</h5></div></div><div></div></div><p>
                  Set this to <tt class="literal">true</tt> if you wish the post office to attempt
                  to create the tables (and indexes) when it starts. If the tables (or indexes)
                  already exist a <tt class="literal">SQLException</tt> will be thrown by the JDBC driver and
                  ignored by the Persistence Manager, allowing it to continue.
               </p><p>
                  By default the value of <tt class="literal">CreateTablesOnStartup</tt> attribute
                  is set to <tt class="literal">true</tt>
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.postofficename"></a>8.3.2.1.4.&nbsp;PostOfficeName</h5></div></div><div></div></div><p>
                  The name of the post office
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.nodeidview"></a>8.3.2.1.5.&nbsp;NodeIDView</h5></div></div><div></div></div><p>
                  This returns set containing the node ids of all the nodes in the cluster
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.groupname"></a>8.3.2.1.6.&nbsp;GroupName</h5></div></div><div></div></div><p>
                  All post offices in the cluster with the same group name will form a cluster together. Make sure the group name matches with
                  all the nodes in the cluster you want to form a cluster with.
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.messagepullpolicy"></a>8.3.2.1.7.&nbsp;MessagePullPolicy</h5></div></div><div></div></div><p>
                  JBoss Messaging has the ability for queues on one node to pull messages from other nodes when they have exhausted their local messages.
               </p><p>This prevents messages from getting stranded on nodes with slow or no consumers, and balances out message processing across the cluster.</p><p>How, if and when messages are pulled from one node to another is determined by the MessagePullPolicy</p><p>By default this set to <tt class="literal">org.jboss.messaging.core.plugin.postoffice.cluster.NullMessagePullPolicy</tt> which is a dummy
               implementation which never pulls messages from one node to another.</p><p>Whether you need message redistribution or not depends on your application topology - please see the section on clustering configuration for
               more details</p><p>If you require message redistribution then set this value to <tt class="literal">org.jboss.messaging.core.plugin.postoffice.cluster.NullMessagePullPolicy</tt>
               </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Enabling message redistribution can result in the strict JMS message ordering guarantee being lost (i.e. the order of receipt of messages from
               a particular producer is retained). If this is not acceptable then do not enable message redistribution.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.clusterrouterfactory"></a>8.3.2.1.8.&nbsp;ClusterRouterFactory</h5></div></div><div></div></div><p>
                  When a message arrives on a node - JBoss Messaging needs to decide whether to route it to a local queue or a remote queue on a different node.
               </p><p>This setting allows you to specify the factory that determines this routing</p><p>By default this set to <tt class="literal">org.jboss.messaging.core.plugin.postoffice.cluster.DefaultRouterFactory</tt> which always favours
               a local queue if one is available otherwise it round robins amongst other queues.</p><p>The particular router factory you require depends on your application topology - please see the section on clustering configuration for
               more details</p><p>Other values this attribute can be set to are <tt class="literal">org.jboss.messaging.core.plugin.postoffice.cluster.RoundRobinRouterFactory</tt>
               if you do not want to favour the local queue.
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.statetimeout"></a>8.3.2.1.9.&nbsp;StateTimeout</h5></div></div><div></div></div><p>
                  The maximum time to wait when waiting for the group state to arrive when a node joins a pre-existing cluster.
               </p><p>The default value is <tt class="literal">5000</tt> milliseconds
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.casttimeout"></a>8.3.2.1.10.&nbsp;CastTimeout</h5></div></div><div></div></div><p>
                  The maximum time to wait for a reply casting message synchronously
               </p><p>The default value is <tt class="literal">5000</tt> milliseconds
               </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.statssendperiod"></a>8.3.2.1.11.&nbsp;StatsSendPeriod</h5></div></div><div></div></div><p>
                       When clustering, each node in the cluster will broadcast statistics periodically to inform the other nodes of their queues and the number of
                       messages in them. This data is then used by the message redistribution policy to redistribute messages if necessary.
                       This value represents the number of milliseconds between statistics broadcasts.
              </p><p>
                       The default value is <tt class="literal">10000</tt> milliseconds
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.syncchannelconfig"></a>8.3.2.1.12.&nbsp;SyncChannelConfig</h5></div></div><div></div></div><p>
                    JBoss Messaging uses JGroups for all group management. This contains the JGroups stack configuration for the synchronous channel.
              </p><p>The synchronous channel is used for sending request/reeciving responses from other nodes in the cluster</p><p>
               The details of the JGroups configuration won't be discussed here since it is standard JGroups configuration.
                       Detailed information on JGroups can be found in JGroups release documentation or on-line at
                       <a href="http://www.jgroups.org" target="_top">http://www.jgroups.org</a> or
                 <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups" target="_top">http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups</a>
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.asyncchannelconfig"></a>8.3.2.1.13.&nbsp;AsyncChannelConfig</h5></div></div><div></div></div><p>
                    JBoss Messaging uses JGroups for all group management. This contains the JGroups stack configuration for the asynchronous channel.
              </p><p>The asynchronous channel is used for sending sending/receiving messages from other nodes in the cluster</p><p>
               The details of the JGroups configuration won't be discussed here since it is standard JGroups configuration.
                       Detailed information on JGroups can be found in JGroups release documentation or on-line at
                       <a href="http://www.jgroups.org" target="_top">http://www.jgroups.org</a> or
                 <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups" target="_top">http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups</a>
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.postoffice.clustered.attributes.threadpoolsize"></a>8.3.2.1.14.&nbsp;ThreadPoolSize</h5></div></div><div></div></div><p>
                    The post office uses a thread pool for dispatching requests/handling responses from the cluster. This attribute represents the maximum size of
                    that pool
              </p><p>The default value of this is <tt class="literal">50</tt> threads</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.persistencemanager"></a>8.4.&nbsp;Configuring the Persistence Manager</h2></div></div><div></div></div><p>It is the job of the persistence manager to manage all message related persistence.
    </p><p>
       JBoss Messaging ships with a JDBC Persistence Manager used for handling persistence of
       message data in a relational database accessed via JDBC. The Persistence Manager
       implementation is pluggable (the Persistence Manager is a Messaging server plug-in),
       this making possible to provide other implementations for persisting message data in
       non relational stores, file stores etc.
    </p><p>
        The configuration of "persistent" services is grouped in a
        <tt class="filename">xxx-persistence-service.xml</tt> file, where the actual file prefix is
        usually inferred from its corresponding database JDBC connection string. By default,
        Messaging ships with a <tt class="filename">hsqldb-persistence-service.xml</tt>, which configures
        the Messaging server to use the in-VM Hypersonic database instance that comes by default
        with any JBossAS instance.
     </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
        The default Persistence Manager configuration is works out of the box with Hypersonic,
        however it must be stressed that Hypersonic should not be used in a production environment
        mainly due to its limited support for transaction isolation and its propensity to behave
        erratically under high load.
        </p><p>
           The
           <a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=ConfigJBossMQDB" target="_top">Critique of Hypersonic</a>
           wiki page outlines some of the well-known issues occuring when using this database.
        </p></div><p>
        JBoss Messaging also ships with pre-made Persistence Manager configurations for MySQL,
        Oracle, PostgreSQL, Sybase and MS SQL Server. The example <tt class="filename">mysql-persistence-service.xml</tt>,
        <tt class="filename">oracle-persistence-service.xml</tt>,
        <tt class="filename">postgres-persistence-service.xml</tt> and
        <tt class="filename">sybase-persistence-service.xml</tt> and
        <tt class="filename">mssql-persistence-service.xml</tt> configuration files are available
        in the <tt class="filename">examples/config</tt> directory of the release bundle.
     </p><p>
        Users are encouraged to contribute their own configuration files where we will thoroughly test them before certifying them for suppported use
        with JBoss Messaging. The JDBC Persistence Manager has been designed
        to use standard SQL for the DML so writing a JDBC Persistence Manager configuration for another
        database is usually only a fairly simple matter of changing DDL in the configuration
        which is likely to be different for different databases.
     </p><p>
        The default Hypersonic persistence configuration file is listed below:
     </p><pre class="programlisting">

      &lt;server&gt;

         &lt;mbean code="org.jboss.messaging.core.plugin.JDBCPersistenceManagerService"
            name="jboss.messaging:service=PersistenceManager"
            xmbean-dd="xmdesc/JDBCPersistenceManager-xmbean.xml"&gt;
            &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
            &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
            &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
            &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
            &lt;attribute name="UsingBatchUpdates"&gt;false&lt;/attribute&gt;
            &lt;attribute name="MaxParams"&gt;500&lt;/attribute&gt;
         &lt;/mbean&gt;

         &lt;mbean code="org.jboss.messaging.core.plugin.DefaultPostOfficeService"
            name="jboss.messaging:service=PostOffice"
            xmbean-dd="xmdesc/DefaultPostOffice-xmbean.xml"&gt;
            &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
            &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
            &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
            &lt;attribute name="PostOfficeName"&gt;JMS&lt;/attribute&gt;
            &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
            &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
         &lt;/mbean&gt;

         &lt;mbean code="org.jboss.jms.server.plugin.JDBCJMSUserManagerService"
            name="jboss.messaging:service=JMSUserManager"
            xmbean-dd="xmdesc/JMSUserManager-xmbean.xml"&gt;
            &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
            &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
            &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
            &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
            &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
      POPULATE.TABLES.1=INSERT INTO JBM_USER (USER_ID,PASSWD,CLIENTID) VALUES ('dilbert','dogbert','dilbert-id')
            ]]&gt;&lt;/attribute&gt;
         &lt;/mbean&gt;

      &lt;/server&gt;

   </pre><p>
        An example of a Persistence Manager configuration for a MySQL database follows:
     </p><pre class="programlisting">

   &lt;server&gt;

      &lt;mbean code="org.jboss.messaging.core.plugin.JDBCPersistenceManagerService"
            name="jboss.messaging:service=PersistenceManager"
            xmbean-dd="xmdesc/JDBCPersistenceManager-xmbean.xml"&gt;
            &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
            &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
            &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
            &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
            &lt;attribute name="UsingBatchUpdates"&gt;true&lt;/attribute&gt;
            &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
      CREATE_MESSAGE_REFERENCE=CREATE TABLE JBM_MSG_REF (CHANNEL_ID BIGINT, MESSAGE_ID BIGINT, TRANSACTION_ID BIGINT, STATE CHAR(1), ORD BIGINT, PAGE_ORD BIGINT, DELIVERY_COUNT INTEGER, SCHED_DELIVERY BIGINT, PRIMARY KEY(CHANNEL_ID, MESSAGE_ID))
      CREATE_IDX_MESSAGE_REF_TX=CREATE INDEX JBM_MSG_REF_TX ON JBM_MSG_REF (TRANSACTION_ID)
      CREATE_IDX_MESSAGE_REF_ORD=CREATE INDEX JBM_MSG_REF_ORD ON JBM_MSG_REF (ORD)
      CREATE_IDX_MESSAGE_REF_PAGE_ORD=CREATE INDEX JBM_MSG_REF_PAGE_ORD ON JBM_MSG_REF (PAGE_ORD)
      CREATE_IDX_MESSAGE_REF_MESSAGE_ID=CREATE INDEX JBM_MSG_REF_MESSAGE_ID ON JBM_MSG_REF (MESSAGE_ID)
      CREATE_IDX_MESSAGE_REF_SCHED_DELIVERY=CREATE INDEX JBM_MSG_REF_SCHED_DELIVERY ON JBM_MSG_REF (SCHED_DELIVERY)
      CREATE_MESSAGE=CREATE TABLE JBM_MSG (MESSAGE_ID BIGINT, RELIABLE CHAR(1), EXPIRATION BIGINT, TIMESTAMP BIGINT, PRIORITY TINYINT, HEADERS MEDIUMBLOB, PAYLOAD LONGBLOB, CHANNEL_COUNT INTEGER, TYPE TINYINT, PRIMARY KEY (MESSAGE_ID))
      CREATE_TRANSACTION=CREATE TABLE JBM_TX (TRANSACTION_ID BIGINT, BRANCH_QUAL VARBINARY(254), FORMAT_ID INTEGER, GLOBAL_TXID VARBINARY(254), PRIMARY KEY (TRANSACTION_ID))
      CREATE_COUNTER=CREATE TABLE JBM_COUNTER (NAME VARCHAR(255), NEXT_ID BIGINT, PRIMARY KEY(NAME))
      INSERT_MESSAGE_REF=INSERT INTO JBM_MSG_REF (CHANNEL_ID, MESSAGE_ID, TRANSACTION_ID, STATE, ORD, PAGE_ORD, DELIVERY_COUNT, SCHED_DELIVERY) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      DELETE_MESSAGE_REF=DELETE FROM JBM_MSG_REF WHERE MESSAGE_ID=? AND CHANNEL_ID=? AND STATE='C'
      UPDATE_MESSAGE_REF=UPDATE JBM_MSG_REF SET TRANSACTION_ID=?, STATE='-' WHERE MESSAGE_ID=? AND CHANNEL_ID=? AND STATE='C'
      UPDATE_PAGE_ORDER=UPDATE JBM_MSG_REF SET PAGE_ORD = ? WHERE MESSAGE_ID=? AND CHANNEL_ID=?
      COMMIT_MESSAGE_REF1=UPDATE JBM_MSG_REF SET STATE='C', TRANSACTION_ID = NULL WHERE TRANSACTION_ID=? AND STATE='+'
      COMMIT_MESSAGE_REF2=DELETE FROM JBM_MSG_REF WHERE TRANSACTION_ID=? AND STATE='-'
      ROLLBACK_MESSAGE_REF1=DELETE FROM JBM_MSG_REF WHERE TRANSACTION_ID=? AND STATE='+'
      ROLLBACK_MESSAGE_REF2=UPDATE JBM_MSG_REF SET STATE='C', TRANSACTION_ID = NULL WHERE TRANSACTION_ID=? AND STATE='-'
      LOAD_PAGED_REFS=SELECT MESSAGE_ID, DELIVERY_COUNT, PAGE_ORD, SCHED_DELIVERY FROM JBM_MSG_REF WHERE CHANNEL_ID = ? AND PAGE_ORD BETWEEN ? AND ? ORDER BY PAGE_ORD
      LOAD_UNPAGED_REFS=SELECT MESSAGE_ID, DELIVERY_COUNT, SCHED_DELIVERY FROM JBM_MSG_REF WHERE STATE = 'C' AND CHANNEL_ID = ? AND PAGE_ORD IS NULL ORDER BY ORD
      LOAD_REFS=SELECT MESSAGE_ID, DELIVERY_COUNT, SCHED_DELIVERY FROM JBM_MSG_REF WHERE STATE = 'C' AND CHANNEL_ID = ? ORDER BY ORD
      UPDATE_REFS_NOT_PAGED=UPDATE JBM_MSG_REF SET PAGE_ORD = NULL WHERE PAGE_ORD BETWEEN ? AND ? AND CHANNEL_ID=?
      SELECT_MIN_MAX_PAGE_ORD=SELECT MIN(PAGE_ORD), MAX(PAGE_ORD) FROM JBM_MSG_REF WHERE CHANNEL_ID = ?
      SELECT_EXISTS_REF=SELECT MESSAGE_ID FROM JBM_MSG_REF WHERE CHANNEL_ID = ? AND MESSAGE_ID = ?
      SELECT_EXISTS_REF_MESSAGE_ID=SELECT MESSAGE_ID FROM JBM_MSG_REF WHERE MESSAGE_ID = ?
      UPDATE_DELIVERY_COUNT=UPDATE JBM_MSG_REF SET DELIVERY_COUNT = ? WHERE CHANNEL_ID = ? AND MESSAGE_ID = ?
      UPDATE_CHANNEL_ID=UPDATE JBM_MSG_REF SET CHANNEL_ID = ? WHERE CHANNEL_ID = ?
      LOAD_MESSAGES=SELECT MESSAGE_ID, RELIABLE, EXPIRATION, TIMESTAMP, PRIORITY, HEADERS, PAYLOAD, TYPE FROM JBM_MSG
      INSERT_MESSAGE=INSERT INTO JBM_MSG (MESSAGE_ID, RELIABLE, EXPIRATION, TIMESTAMP, PRIORITY, HEADERS, PAYLOAD, CHANNEL_COUNT, TYPE) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      INC_CHANNEL_COUNT=UPDATE JBM_MSG SET CHANNEL_COUNT = CHANNEL_COUNT + 1 WHERE MESSAGE_ID=?
      DEC_CHANNEL_COUNT=UPDATE JBM_MSG SET CHANNEL_COUNT = CHANNEL_COUNT - 1 WHERE MESSAGE_ID=?
      DELETE_MESSAGE=DELETE FROM JBM_MSG WHERE MESSAGE_ID=? AND CHANNEL_COUNT=0
      MESSAGE_ID_COLUMN=MESSAGE_ID
      MESSAGE_EXISTS=SELECT MESSAGE_ID FROM JBM_MSG WHERE MESSAGE_ID = ? FOR UPDATE
      INSERT_TRANSACTION=INSERT INTO JBM_TX (TRANSACTION_ID, BRANCH_QUAL, FORMAT_ID, GLOBAL_TXID) VALUES(?, ?, ?, ?)
      DELETE_TRANSACTION=DELETE FROM JBM_TX WHERE TRANSACTION_ID = ?
      SELECT_PREPARED_TRANSACTIONS=SELECT TRANSACTION_ID, BRANCH_QUAL, FORMAT_ID, GLOBAL_TXID FROM JBM_TX
      SELECT_MESSAGE_ID_FOR_REF=SELECT MESSAGE_ID, CHANNEL_ID FROM JBM_MSG_REF WHERE TRANSACTION_ID = ? AND STATE = '+' ORDER BY ORD
      SELECT_MESSAGE_ID_FOR_ACK=SELECT MESSAGE_ID, CHANNEL_ID FROM JBM_MSG_REF WHERE TRANSACTION_ID = ? AND STATE = '-' ORDER BY ORD
      UPDATE_COUNTER=UPDATE JBM_COUNTER SET NEXT_ID = ? WHERE NAME=?
      SELECT_COUNTER=SELECT NEXT_ID FROM JBM_COUNTER WHERE NAME=? FOR UPDATE
      INSERT_COUNTER=INSERT INTO JBM_COUNTER (NAME, NEXT_ID) VALUES (?, ?)
      SELECT_ALL_CHANNELS=SELECT DISTINCT(CHANNEL_ID) FROM JBM_MSG_REF
            ]]&gt;&lt;/attribute&gt;
            &lt;attribute name="MaxParams"&gt;500&lt;/attribute&gt;
      &lt;/mbean&gt;

      &lt;mbean code="org.jboss.messaging.core.plugin.DefaultPostOfficeService"
         name="jboss.messaging:service=PostOffice"
         xmbean-dd="xmdesc/DefaultPostOffice-xmbean.xml"&gt;
         &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
         &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
         &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
         &lt;attribute name="PostOfficeName"&gt;JMS&lt;/attribute&gt;
         &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
         &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
         &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
   CREATE_POSTOFFICE_TABLE=CREATE TABLE JBM_POSTOFFICE (POSTOFFICE_NAME VARCHAR(255), NODE_ID INTEGER, QUEUE_NAME VARCHAR(1023), COND VARCHAR(1023), SELECTOR VARCHAR(1023), CHANNEL_ID BIGINT, CLUSTERED CHAR(1))
   INSERT_BINDING=INSERT INTO JBM_POSTOFFICE (POSTOFFICE_NAME, NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED) VALUES (?, ?, ?, ?, ?, ?, ?)
   DELETE_BINDING=DELETE FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME=? AND NODE_ID=? AND QUEUE_NAME=?
   LOAD_BINDINGS=SELECT NODE_ID, QUEUE_NAME, COND, SELECTOR, CHANNEL_ID, CLUSTERED FROM JBM_POSTOFFICE WHERE POSTOFFICE_NAME  = ?
         ]]&gt;&lt;/attribute&gt;
      &lt;/mbean&gt;

      &lt;mbean code="org.jboss.jms.server.plugin.JDBCJMSUserManagerService"
         name="jboss.messaging:service=JMSUserManager"
         xmbean-dd="xmdesc/JMSUserManager-xmbean.xml"&gt;
         &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
         &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
         &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
         &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
         &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
   CREATE_USER_TABLE=CREATE TABLE JBM_USER (USER_ID VARCHAR(32) NOT NULL, PASSWD VARCHAR(32) NOT NULL, CLIENTID VARCHAR(128), PRIMARY KEY(USER_ID))
   CREATE_ROLE_TABLE=CREATE TABLE JBM_ROLE (ROLE_ID VARCHAR(32) NOT NULL, USER_ID VARCHAR(32) NOT NULL, PRIMARY KEY(USER_ID, ROLE_ID))
   SELECT_PRECONF_CLIENTID=SELECT CLIENTID FROM JBM_USER WHERE USER_ID=?
   POPULATE.TABLES.1=INSERT INTO JBM_USER (USER_ID,PASSWD,CLIENTID) VALUES ('dilbert','dogbert','dilbert-id')
         ]]&gt;&lt;/attribute&gt;
      &lt;/mbean&gt;

   &lt;/server&gt;

  </pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.persistencemanager.attributes"></a>8.4.1.&nbsp;
        We now discuss the MBean attributes of the PersistenceManager MBean
        </h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.createtables"></a>8.4.1.1.&nbsp;CreateTablesOnStartup</h4></div></div><div></div></div><p>
              Set this to <tt class="literal">true</tt> if you wish the Persistence Manager to attempt
              to create the tables (and indexes) when it starts. If the tables (or indexes)
              already exist a <tt class="literal">SQLException</tt> will be thrown by the JDBC driver and
              ignored by the Persistence Manager, allowing it to continue.
           </p><p>
              By default the value of <tt class="literal">CreateTablesOnStartup</tt> attribute
              is set to <tt class="literal">true</tt>
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.batchupdates"></a>8.4.1.2.&nbsp;UsingBatchUpdates</h4></div></div><div></div></div><p>
              Set this to <tt class="literal">true</tt> if the database supports JDBC batch updates.
              The JDBC Persistence Manager will then group multiple database updates in batches
              to aid performance.
           </p><p>
            By default the value of <tt class="literal">UsingBatchUpdates</tt> attribute
            is set to <tt class="literal">false</tt>
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.binarystream"></a>8.4.1.3.&nbsp;UsingBinaryStream</h4></div></div><div></div></div><p>
              Set this to <tt class="literal">true</tt> if you want messages to be store and read using a JDBC binary stream rather than using
              getBytes(), setBytes(). Some database has limits on the maximum number of bytes that can be get/set using getBytes()/setBytes().
           </p><p>
            By default the value of <tt class="literal">UsingBinaryStream</tt> attribute
            is set to <tt class="literal">true</tt>
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.trailingbyte"></a>8.4.1.4.&nbsp;UsingTrailingByte</h4></div></div><div></div></div><p>
              Certain version of Sybase are known to truncate blobs if they have trailing zeros. To prevent this if this attribute is set to
              <tt class="literal">true</tt> then a trailing non zero byte will be added and removed to each blob before and after persistence to prevent
              the database from truncating it. Currently this is only known to be necessary for Sybase.
           </p><p>
            By default the value of <tt class="literal">UsingTrailingByte</tt> attribute
            is set to <tt class="literal">false</tt>
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.sqlproperties"></a>8.4.1.5.&nbsp;SQLProperties</h4></div></div><div></div></div><p>
              This is where the DDL and DML for the particular database is specified.
              If a particular DDL or DML statement is not overridden, the default Hypersonic
              configuration will be used for that statement.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.persistencemanager.attributes.maxparams"></a>8.4.1.6.&nbsp;MaxParams</h4></div></div><div></div></div><p>
             When loading messages the persistence manager will generate prepared statements with many parameters. This value tells the persistence
             manager what the absolute maximum number of parameters are allowable per prepared statement.

          </p><p>
           By default the value of <tt class="literal">MaxParams</tt> attribute
           is set to <tt class="literal">100</tt>
        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.jmsusermanager"></a>8.5.&nbsp;Configuring the JMS user manager</h2></div></div><div></div></div><p>The JMS user manager handles the mapping of pre-configured client IDs to users and also managers the user and role tables which may or
      may not be used depending on which login module you have configured</p><p>Here is an example JMSUserManager configuration</p><pre class="programlisting">

   &lt;mbean code="org.jboss.jms.server.plugin.JDBCJMSUserManagerService"
      name="jboss.messaging:service=JMSUserManager"
      xmbean-dd="xmdesc/JMSUserManager-xmbean.xml"&gt;
      &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
      &lt;depends optional-attribute-name="TransactionManager"&gt;jboss:service=TransactionManager&lt;/depends&gt;
      &lt;attribute name="DataSource"&gt;java:/DefaultDS&lt;/attribute&gt;
      &lt;attribute name="CreateTablesOnStartup"&gt;true&lt;/attribute&gt;
      &lt;attribute name="SqlProperties"&gt;&lt;![CDATA[
CREATE_USER_TABLE=CREATE TABLE JBM_USER (USER_ID VARCHAR(32) NOT NULL, PASSWD VARCHAR(32) NOT NULL, CLIENTID VARCHAR(128), PRIMARY KEY(USER_ID))
CREATE_ROLE_TABLE=CREATE TABLE JBM_ROLE (ROLE_ID VARCHAR(32) NOT NULL, USER_ID VARCHAR(32) NOT NULL, PRIMARY KEY(USER_ID, ROLE_ID))
SELECT_PRECONF_CLIENTID=SELECT CLIENTID FROM JBM_USER WHERE USER_ID=?
POPULATE.TABLES.1=INSERT INTO JBM_USER (USER_ID,PASSWD,CLIENTID) VALUES ('dilbert','dogbert','dilbert-id')
      ]]&gt;&lt;/attribute&gt;
   &lt;/mbean&gt;

      </pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.jmsusermanager.attributes"></a>8.5.1.&nbsp;
        We now discuss the MBean attributes of the PersistenceManager MBean
        </h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.jmsusermanager.attributes.createtables"></a>8.5.1.1.&nbsp;CreateTablesOnStartup</h4></div></div><div></div></div><p>
              Set this to <tt class="literal">true</tt> if you wish the JMS user manager to attempt
              to create the tables (and indexes) when it starts. If the tables (or indexes)
              already exist a <tt class="literal">SQLException</tt> will be thrown by the JDBC driver and
              ignored by the Persistence Manager, allowing it to continue.
           </p><p>
              By default the value of <tt class="literal">CreateTablesOnStartup</tt> attribute
              is set to <tt class="literal">true</tt>
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.jmsusermanager.attributes.batchupdates"></a>8.5.1.2.&nbsp;UsingBatchUpdates</h4></div></div><div></div></div><p>
              Set this to <tt class="literal">true</tt> if the database supports JDBC batch updates.
              The JDBC Persistence Manager will then group multiple database updates in batches
              to aid performance.
           </p><p>
            By default the value of <tt class="literal">UsingBatchUpdates</tt> attribute
            is set to <tt class="literal">false</tt>
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.jmsusermanager.attributes.sqlproperties"></a>8.5.1.3.&nbsp;SQLProperties</h4></div></div><div></div></div><p>
              This is where the DDL and DML for the particular database is specified.
              If a particular DDL or DML statement is not overridden, the default Hypersonic
              configuration will be used for that statement.
           </p><p>
           Default user and role data can also be specified here. Any data to be inserted must be specified with property names starting with
           <tt class="literal">POPULATE.TABLES</tt> as in the above example.
           </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.destination"></a>8.6.&nbsp;Configuring Destinations</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.preconf.destinations"></a>8.6.1.&nbsp;Pre-configured destinations</h3></div></div><div></div></div><p>
           JBoss Messaging  ships with a default set of pre-configured destinations that will be
           deployed during the server start up. The file that contains configuration for these
           destinations is <tt class="filename">destinations-service.xml</tt>. A section of
           this file is listed below:
        </p><pre class="programlisting">
   &lt;!--
      The Default Dead Letter Queue. This destination is a dependency of an EJB MDB container.
   --&gt;

   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=DLQ"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
   &lt;/mbean&gt;


   &lt;mbean code="org.jboss.jms.server.destination.TopicService"
      name="jboss.messaging.destination:service=Topic,name=testTopic"
      xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="SecurityConfig"&gt;
         &lt;security&gt;
            &lt;role name="guest" read="true" write="true"/&gt;
            &lt;role name="publisher" read="true" write="true" create="false"/&gt;
            &lt;role name="durpublisher" read="true" write="true" create="true"/&gt;
         &lt;/security&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.destination.TopicService"
      name="jboss.messaging.destination:service=Topic,name=securedTopic"
      xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="SecurityConfig"&gt;
         &lt;security&gt;
            &lt;role name="publisher" read="true" write="true" create="false"/&gt;
         &lt;/security&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;


   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=testQueue"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="SecurityConfig"&gt;
         &lt;security&gt;
            &lt;role name="guest" read="true" write="true"/&gt;
            &lt;role name="publisher" read="true" write="true" create="false"/&gt;
            &lt;role name="noacc" read="false" write="false" create="false"/&gt;
         &lt;/security&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=A"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
   &lt;/mbean&gt;


   &lt;!-- It's possible for indiviual queues and topics to use a specific queue for
   an expiry or DLQ --&gt;

   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=PrivateDLQ"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=PrivateExpiryQueue"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.destination.QueueService"
      name="jboss.messaging.destination:service=Queue,name=QueueWithOwnDLQAndExpiryQueue"
      xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="DLQ"&gt;jboss.messaging.destination:service=Queue,name=PrivateDLQ&lt;/attribute&gt;
      &lt;attribute name="ExpiryQueue"&gt;jboss.messaging.destination:service=Queue,name=PrivateExpiryQueue&lt;/attribute&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.jboss.jms.server.destination.TopicService"
      name="jboss.messaging.destination:service=Topic,name=TopicWithOwnDLQAndExpiryQueue"
      xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="DLQ"&gt;jboss.messaging.destination:service=Queue,name=PrivateDLQ&lt;/attribute&gt;
      &lt;attribute name="ExpiryQueue"&gt;jboss.messaging.destination:service=Queue,name=PrivateExpiryQueue&lt;/attribute&gt;
   &lt;/mbean&gt;


   &lt;mbean code="org.jboss.jms.server.destination.TopicService"
      name="jboss.messaging.destination:service=Topic,name=TopicWithOwnRedeliveryDelay"
      xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="RedeliveryDelay"&gt;5000&lt;/attribute&gt;
   &lt;/mbean&gt;


   &lt;mbean code="org.jboss.jms.server.destination.TopicService"
      name="jboss.messaging.destination:service=Topic,name=testDistributedTopic"
      xmbean-dd="xmdesc/Topic-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;jboss.messaging:service=ServerPeer&lt;/depends&gt;
      &lt;depends&gt;jboss.messaging:service=PostOffice&lt;/depends&gt;
      &lt;attribute name="Clustered"&gt;true&lt;/attribute&gt;
   &lt;/mbean&gt;
....
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.destination.queue"></a>8.6.2.&nbsp;Configuring queues</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.queue.attributes"></a>8.6.2.1.&nbsp;
            We now discuss the MBean attributes of the Queue MBean
            </h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.name"></a>8.6.2.1.1.&nbsp;Name</h5></div></div><div></div></div><p>The name of the queue</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.jndiName"></a>8.6.2.1.2.&nbsp;JNDIName</h5></div></div><div></div></div><p>The JNDI name where the queue is bound</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.dlq"></a>8.6.2.1.3.&nbsp;DLQ</h5></div></div><div></div></div><p>The DLQ used for this queue. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.expiryqueue"></a>8.6.2.1.4.&nbsp;ExpiryQueue</h5></div></div><div></div></div><p>The Expiry queue used for this queue. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.redeliverydelay"></a>8.6.2.1.5.&nbsp;RedeliveryDelay</h5></div></div><div></div></div><p>The redlivery delay to be used for this queue. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.security"></a>8.6.2.1.6.&nbsp;Destination Security Configuration</h5></div></div><div></div></div><p>
                    <tt class="literal">SecurityConfig</tt> - allows you to determine which roles are allowed
                    to read, write and create on the destination. It has exactly the same syntax and
                    semantics as the security configuration in JBossMQ destinations.
                 </p><p>
                    The <tt class="literal">SecurityConfig</tt> element should contain one
                    <tt class="literal">&lt;security&gt;</tt> element. The <tt class="literal">&lt;security&gt;</tt>
                    element can contain multiple <tt class="literal">&lt;role&gt;</tt> elements.
                    Each <tt class="literal">&lt;role&gt;</tt> element defines the access for that
                    particular role.
                 </p><p>
                    If the <tt class="literal">read</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to read (create consumers, receive messaages or browse) this destination.
                 </p><p>
                    If the <tt class="literal">write</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to write (create producers or send messages) to this destination.
                 </p><p>
                    If the <tt class="literal">create</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to create durable subscriptions on this destination.
                 </p><p>
                    Note that the security configuration for a destination is optional. If a
                    <tt class="literal">SecurityConfig</tt> element is not specifed then the default
                    security configuration from the Server Peer will be used.
                 </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.paging"></a>8.6.2.1.7.&nbsp;Destination paging parameters</h5></div></div><div></div></div><p>
                 'Pageable Channels' are a sophisticated new feature available in JBoss Messaging.
              </p><p>
                 If your application needs to support very large queues or subscriptions containing
                 potentially millions of messages, then it's not possible to store them all in
                 memory at once.
              </p><p>
                 JBoss Messaging solves this problem but letting you specify the
                 maximum number of messages that can be stored in memory at any one time,
                 on a queue-by-queue, or topic-by-topic basis. JBoss Messaging then pages messages
                 to and from storage transparently in blocks, allowing queues and subscriptions to
                 grow to very large sizes without any performance degradation as channel size increases.
              </p><p>
                 This has been tested with in excess of 10 million 2K messages on very basic hardware
                 and has the potential to scale to much larger number of messages.
              </p><p>
                 The individual parameters are:
              </p><p>
                 <tt class="literal">FullSize</tt> - this is the maximum number of messages held by the
                 queue or topic subscriptions in memory at any one time. The actual queue or
                 subscription can hold many more messages than this but these are paged to and
                 from storage as necessary as messages are added or consumed.
              </p><p>
                 <tt class="literal">PageSize</tt> - When loading messages from the queue or subscrition
                 this is the maximum number of messages to pre-load in one operation.
              </p><p>
                 <tt class="literal">DownCacheSize</tt> - When paging messages to storage from the queue
                 they first go into a "Down Cache" before being written to storage. This enables the
                 write to occur as a single operation thus aiding performance. This setting determines
                 the max number of messages that the Down Cache will hold before they are flushed
                 to storage.
              </p><p>
                 If no values for <tt class="literal">FullSize</tt>, <tt class="literal">PageSize</tt>,
                 or <tt class="literal">DownCacheSize</tt> are specified they will default to values
                 75000, 2000, 2000 respectively.
              </p><p>
                 If you want to specify the paging parameters used for temporary queues then you need to specify them
                 on the appropriate connection factory.
                 See connection factory configuration for details.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.createdprogrammatically"></a>8.6.2.1.8.&nbsp;CreatedProgrammatically</h5></div></div><div></div></div><p>
                 Returns <tt class="literal">true</tt> if the queue was created programmatically
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.messagecount"></a>8.6.2.1.9.&nbsp;MessageCount</h5></div></div><div></div></div><p>
                 Returns the total number of messages in the queue = number not being delivered + number being delivered + number being scheduled
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.scheduledmessagecount"></a>8.6.2.1.10.&nbsp;ScheduledMessageCount</h5></div></div><div></div></div><p>
                 Returns the  number of scheduled messages in the queue. This is the number of messages scheduled to be delivered at a later date.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.maxsize"></a>8.6.2.1.11.&nbsp;MaxSize</h5></div></div><div></div></div><p>
                 A maximum size (in number of messages) can be specified for a queue. Any messages that arrive beyond this point will be dropped. The default is
                 <tt class="literal">-1</tt> which is unbounded.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.clustered"></a>8.6.2.1.12.&nbsp;Clustered</h5></div></div><div></div></div><p>
                 Clustered destinations must have this set to <tt class="literal">true</tt>
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.messagecounter"></a>8.6.2.1.13.&nbsp;MessageCounter</h5></div></div><div></div></div><p>
                 Each queue maintains a message counter.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.messagecounterstats"></a>8.6.2.1.14.&nbsp;MessageCounterStatistics</h5></div></div><div></div></div><p>
                 The statistics for the message counter
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.messagecounterhistorydaylimit"></a>8.6.2.1.15.&nbsp;MessageCounterHistoryDayLimit</h5></div></div><div></div></div><p>
                 The maximum number of days to hold message counter history for. Overrides any value set on the ServerPeer.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.attributes.consumercount"></a>8.6.2.1.16.&nbsp;ConsumerCount</h5></div></div><div></div></div><p>
                 The number of consumers currently consuming from the queue.
              </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.queue.operations"></a>8.6.2.2.&nbsp;
             We now discuss the MBean operations of the Queue MBean
         </h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.removeallmessages"></a>8.6.2.2.1.&nbsp;RemoveAllMessages</h5></div></div><div></div></div><p>
                Remove (and delete) all messages from the queue.
                </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Use this with caution. It will permanently delete all messages from the queue</div><p>
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.listallmessages"></a>8.6.2.2.2.&nbsp;ListAllMessages</h5></div></div><div></div></div><p>
                List all messages currently in the queue
             </p><p>There are two overloaded versions of this operation: One takes a JMS selector as an argument, the other does not. By using the selector
             you can retrieve a subset of the messages in the queue that match the criteria</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.listdurablemessages"></a>8.6.2.2.3.&nbsp;ListDurableMessages</h5></div></div><div></div></div><p>
                As listAllMessages but only lists the durable messages
             </p><p>There are two overloaded versions of this operation: One takes a JMS selector as an argument, the other does not. By using the selector
             you can retrieve a subset of the messages in the queue that match the criteria</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.listnondurablemessages"></a>8.6.2.2.4.&nbsp;ListNonDurableMessages</h5></div></div><div></div></div><p>
                As listAllMessages but only lists the non durable messages
             </p><p>There are two overloaded versions of this operation: One takes a JMS selector as an argument, the other does not. By using the selector
             you can retrieve a subset of the messages in the queue that match the criteria</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.resetmessagecounter"></a>8.6.2.2.5.&nbsp;ResetMessageCounter</h5></div></div><div></div></div><p>
                Resets the message counter to zero.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.resetmessagecounterhistory"></a>8.6.2.2.6.&nbsp;ResetMessageCounterHistory</h5></div></div><div></div></div><p>
                Resets the message counter history.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.listmessagecounterashtml"></a>8.6.2.2.7.&nbsp;ListMessageCounterAsHTML</h5></div></div><div></div></div><p>
                Lists the message counter in an easy to display HTML format
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.queue.operations.listmessagecounterhistoryashtml"></a>8.6.2.2.8.&nbsp;ListMessageCounterHistoryAsHTML</h5></div></div><div></div></div><p>
                Lists the message counter history in an easy to display HTML format
             </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.destination.topics"></a>8.6.3.&nbsp;Configuring topics</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.topic.attributes"></a>8.6.3.1.&nbsp;
            We now discuss the MBean attributes of the Topic MBean
            </h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.name"></a>8.6.3.1.1.&nbsp;Name</h5></div></div><div></div></div><p>The name of the topic</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.jndiName"></a>8.6.3.1.2.&nbsp;JNDIName</h5></div></div><div></div></div><p>The JNDI name where the topic is bound</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.dlq"></a>8.6.3.1.3.&nbsp;DLQ</h5></div></div><div></div></div><p>The DLQ used for this topic. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.expiryqueue"></a>8.6.3.1.4.&nbsp;ExpiryQueue</h5></div></div><div></div></div><p>The Expiry queue used for this topic. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.redeliverydelay"></a>8.6.3.1.5.&nbsp;RedeliveryDelay</h5></div></div><div></div></div><p>The redelivery delay to be used for this topic. Overrides any value set on the ServerPeer config</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.security"></a>8.6.3.1.6.&nbsp;Destination Security Configuration</h5></div></div><div></div></div><p>
                    <tt class="literal">SecurityConfig</tt> - allows you to determine which roles are allowed
                    to read, write and create on the destination. It has exactly the same syntax and
                    semantics as the security configuration in JBossMQ destinations.
                 </p><p>
                    The <tt class="literal">SecurityConfig</tt> element should contain one
                    <tt class="literal">&lt;security&gt;</tt> element. The <tt class="literal">&lt;security&gt;</tt>
                    element can contain multiple <tt class="literal">&lt;role&gt;</tt> elements.
                    Each <tt class="literal">&lt;role&gt;</tt> element defines the access for that
                    particular role.
                 </p><p>
                    If the <tt class="literal">read</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to read (create consumers, receive messaages or browse) this destination.
                 </p><p>
                    If the <tt class="literal">write</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to write (create producers or send messages) to this destination.
                 </p><p>
                    If the <tt class="literal">create</tt> attribute is <tt class="literal">true</tt> then that role
                    will be able to create durable subscriptions on this destination.
                 </p><p>
                    Note that the security configuration for a destination is optional. If a
                    <tt class="literal">SecurityConfig</tt> element is not specifed then the default
                    security configuration from the Server Peer will be used.
                 </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.paging"></a>8.6.3.1.7.&nbsp;Destination paging parameters</h5></div></div><div></div></div><p>
                 'Pageable Channels' are a sophisticated new feature available in JBoss Messaging.
              </p><p>
                 If your application needs to support very large queues or subscriptions containing
                 potentially millions of messages, then it's not possible to store them all in
                 memory at once.
              </p><p>
                 JBoss Messaging solves this problem but letting you specify the
                 maximum number of messages that can be stored in memory at any one time,
                 on a queue-by-queue, or topic-by-topic basis. JBoss Messaging then pages messages
                 to and from storage transparently in blocks, allowing queues and subscriptions to
                 grow to very large sizes without any performance degradation as channel size increases.
              </p><p>
                 This has been tested with in excess of 10 million 2K messages on very basic hardware
                 and has the potential to scale to much larger number of messages.
              </p><p>
                 The individual parameters are:
              </p><p>
                 <tt class="literal">FullSize</tt> - this is the maximum number of messages held by the
                 queue or topic subscriptions in memory at any one time. The actual queue or
                 subscription can hold many more messages than this but these are paged to and
                 from storage as necessary as messages are added or consumed.
              </p><p>
                 <tt class="literal">PageSize</tt> - When loading messages from the queue or subscrition
                 this is the maximum number of messages to pre-load in one operation.
              </p><p>
                 <tt class="literal">DownCacheSize</tt> - When paging messages to storage from the queue
                 they first go into a "Down Cache" before being written to storage. This enables the
                 write to occur as a single operation thus aiding performance. This setting determines
                 the max number of messages that the Down Cache will hold before they are flushed
                 to storage.
              </p><p>
                 If no values for <tt class="literal">FullSize</tt>, <tt class="literal">PageSize</tt>,
                 or <tt class="literal">DownCacheSize</tt> are specified they will default to values
                 75000, 2000, 2000 respectively.
              </p><p>
                 If you want to specify the paging parameters used for temporary queues then you need to specify them
                 on the appropriate connection factory.
                 See connection factory configuration for details.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.createdprogrammatically"></a>8.6.3.1.8.&nbsp;CreatedProgrammatically</h5></div></div><div></div></div><p>
                 Returns <tt class="literal">true</tt> if the topic was created programmatically
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.maxsize"></a>8.6.3.1.9.&nbsp;MaxSize</h5></div></div><div></div></div><p>
                 A maximum size (in number of messages) can be specified for a topic subscription. Any messages that arrive beyond this point will be dropped. The default is
                 <tt class="literal">-1</tt> which is unbounded.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.clustered"></a>8.6.3.1.10.&nbsp;Clustered</h5></div></div><div></div></div><p>
                 Clustered destinations must have this set to <tt class="literal">true</tt>
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.messagecounterhistorydaylimit"></a>8.6.3.1.11.&nbsp;MessageCounterHistoryDayLimit</h5></div></div><div></div></div><p>
                 The maximum number of days to hold message counter history for. Overrides any value set on the ServerPeer.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.messagecounters"></a>8.6.3.1.12.&nbsp;MessageCounters</h5></div></div><div></div></div><p>
                 Return a list of the message counters for the subscriptions of this topic.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.allmessagecount"></a>8.6.3.1.13.&nbsp;AllMessageCount</h5></div></div><div></div></div><p>
                 Return the total number of messages in all subscriptions of this topic.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.durablemessagecount"></a>8.6.3.1.14.&nbsp;DurableMessageCount</h5></div></div><div></div></div><p>
                 Return the total number of durable messages in all subscriptions of this topic.
              </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.nondurablemessagecount"></a>8.6.3.1.15.&nbsp;NonDurableMessageCount</h5></div></div><div></div></div><p>
               Return the total number of non durable messages in all subscriptions of this topic.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.allsubscriptionscount"></a>8.6.3.1.16.&nbsp;AllSubscriptionsCount</h5></div></div><div></div></div><p>
               The count of all subscriptions on this topic
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributes.durablesubscriptionscount"></a>8.6.3.1.17.&nbsp;DurableSubscriptionsCount</h5></div></div><div></div></div><p>
               The count of all durable subscriptions on this topic
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.attributesnon.durablesubscriptionscount"></a>8.6.3.1.18.&nbsp;NonDurableSubscriptionsCount</h5></div></div><div></div></div><p>
               The count of all non durable subscriptions on this topic
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.topic.operations"></a>8.6.3.2.&nbsp;
             We now discuss the MBean operations of the Topic MBean
         </h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.removeallmessages"></a>8.6.3.2.1.&nbsp;RemoveAllMessages</h5></div></div><div></div></div><p>
                Remove (and delete) all messages from the subscriptions of this topic.
                </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Use this with caution. It will permanently delete all messages from the topic</div><p>
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listallsubscriptions"></a>8.6.3.2.2.&nbsp;ListAllSubscriptions</h5></div></div><div></div></div><p>
                List all subscriptions of this topic
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listdurablesubscriptions"></a>8.6.3.2.3.&nbsp;ListDurableSubscriptions</h5></div></div><div></div></div><p>
                List all durable subscriptions of this topic
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listnondurablesubscriptions"></a>8.6.3.2.4.&nbsp;ListNonDurableSubscriptions</h5></div></div><div></div></div><p>
                List all non durable subscriptions of this topic
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listallsubscriptionsashtml"></a>8.6.3.2.5.&nbsp;ListAllSubscriptionsAsHTML</h5></div></div><div></div></div><p>
                List all subscriptions of this topic in an easy to display HTML format
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listdurablesubscriptionsashtml"></a>8.6.3.2.6.&nbsp;ListDurableSubscriptionsAsHTML</h5></div></div><div></div></div><p>
                List all durable subscriptions of this topic in an easy to display HTML format
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listnondurablesubscriptionsashtml"></a>8.6.3.2.7.&nbsp;ListNonDurableSubscriptionsAsHTML</h5></div></div><div></div></div><p>
                List all non durable subscriptions of this topic in an easy to display HTML format
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listallmessages"></a>8.6.3.2.8.&nbsp;ListAllMessages</h5></div></div><div></div></div><p>
                Lists all messages for the specified subscription.
             </p><p> There are two overloaded versions of this operation. One that takes a selector and one that does not.
             By specifyingthe selector you can limit the messages returned.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listnondurablemessages"></a>8.6.3.2.9.&nbsp;ListNonDurableMessages</h5></div></div><div></div></div><p>
                Lists all non durable messages for the specified subscription.
             </p><p> There are two overloaded versions of this operation. One that takes a selector and one that does not.
             By specifyingthe selector you can limit the messages returned.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="conf.destination.topic.operations.listdurablemessages"></a>8.6.3.2.10.&nbsp;ListDurableMessages</h5></div></div><div></div></div><p>
                Lists all durable messages for the specified subscription.
             </p><p> There are two overloaded versions of this operation. One that takes a selector and one that does not.
             By specifyingthe selector you can limit the messages returned.
             </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.destination.new"></a>8.6.4.&nbsp;Deploying a new destination</h3></div></div><div></div></div><p>
           For a JBoss 4.0.x installation, JBoss Messaging is deployed in its own class
           loading domain. Because of that you need to deploy a new destinations to use
           with JBoss Messaging within the same class loading domain.
       </p><p>
           To deploy a new destination, create a new deployment descriptor named
           <tt class="filename">myqueue-service.xml</tt> (or anything else that ends in
           <tt class="literal">-service.xml</tt>) and copy it to the JBoss instance deployment
           directory <tt class="filename">$JBOSS_HOME/server/messaging/deploy</tt>.
        </p><p>
           An example of a scoped destination deployment descriptor is listed below:
        </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;server&gt;
   &lt;loader-repository&gt;jboss.messaging:loader=ScopedLoaderRepository
   &lt;loader-repository-config&gt;java2ParentDelegation=false&lt;/loader-repository-config&gt;
   &lt;/loader-repository&gt;
   &lt;mbean
      code="org.jboss.jms.server.destination.Queue"
     name="jboss.messaging.destination:service=Queue,name=testQueue"
     xmbean-dd="xmdesc/Queue-xmbean.xml"&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;
         jboss.messaging:service=ServerPeer
      &lt;/depends&gt;
      &lt;attribute name="SecurityConfig"&gt;
         &lt;security&gt;
            &lt;role name="guest" read="true"write="true"/&gt;
            &lt;role name="publisher" read="true" write="true" create="false"/&gt;
            &lt;role name="noacc" read="false" write="false" create="false"/&gt;
          &lt;/security&gt;
      &lt;/attribute&gt;
      &lt;attribute name="fullSize"&gt;75000&lt;/attribute&gt;
      &lt;attribute name="pageSize"&gt;2000&lt;/attribute&gt;
      &lt;attribute name="downCacheSize"&gt;2000&lt;/attribute&gt;
   &lt;/mbean&gt;
&lt;/server&gt;
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.connections"></a>8.7.&nbsp;Configuring Connection Factories</h2></div></div><div></div></div><p>
       With the default configuration JBoss Messaging binds just one connection factory in
       JNDI at start-up. This connection factory has no client ID and is bound into the
       following JNDI contexts:
       <tt class="literal">/ConnectionFactory, /XAConnectionFactory, java:/ConnectionFactory, java:/XAConnectionFactory</tt>
    </p><p>
       You may want to configure additional connection factories, for instance if you want to provide
       a default client id for a connection factory, or if you want to bind it in different places
       in JNDI, or if you want different connection factories to use different transports. Deploying
       a new connection factory is equivalent with adding a new ConnectionFactory MBean
       configuration to <tt class="filename">connection-factories-service.xml</tt>.
    </p><p>
        It is also possible to create an entirely
        new service deployment descriptor <tt class="filename">xxx-service.xml</tt> altogether and
        deploy it in <tt class="filename">$JBOSS_HOME/server/messaging/deploy</tt>.
    </p><p>
    Connection factories can either be clustered or non clustered.
    Clustered connection factories create subsequent connections on different nodes of the cluster according to the load balancing policy.
    The default load balancing policy is round robin.
    </p><p>
       An example connection factory configuration is presented below:
     </p><pre class="programlisting">

&lt;server&gt;
   &lt;loader-repository&gt;
      jboss.messaging:loader=ScopedLoaderRepository
         &lt;loader-repository-config&gt;
            java2ParentDelegation=false
         &lt;/loader-repository-config&gt;
   &lt;/loader-repository&gt;
   &lt;mbean
      code="org.jboss.jms.server.connectionfactory.ConnectionFactory"
      name="jboss.messaging.destination:service=ConnectionFactory"
      xmbean-dd="xmdesc/ConnectionFactory-xmbean.xml"&gt;
      &lt;constructor&gt;
         &lt;arg type="java.lang.String" value="myClientID"/&gt;
      &lt;/constructor&gt;
      &lt;depends optional-attribute-name="ServerPeer"&gt;
         jboss.messaging:service=ServerPeer
      &lt;/depends&gt;
      &lt;depends optional-attribute-name="Connector"&gt;
         jboss.messaging:service=Connector,transport=socket
      &lt;/depends&gt;
      &lt;attribute name="PrefetchSize"&gt;10&lt;/attribute&gt;
      &lt;attribute name="DefaultTempQueueFullSize"&gt;1000&lt;/attribute&gt;
      &lt;attribute name="DefaultTempQueuePageSize"&gt;50&lt;/attribute&gt;
      &lt;attribute name="DefaultTempQueueDownCacheSize"&gt;50&lt;/attribute&gt;
      &lt;attribute name="JNDIBindings"&gt;
         &lt;bindings&gt;
            &lt;binding&gt;/MyConnectionFactory1&lt;/binding&gt;
            &lt;binding&gt;/factories/cf1&lt;/binding&gt;&gt;
         &lt;/bindings&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;
&lt;/server&gt;

    </pre><p>
        The above example would create a connection factory with pre-configured client ID
        <tt class="literal">myClientID</tt> and bind the connection factory in two places in
        the JNDI tree: <tt class="literal">/MyConnectionFactory</tt>
        and <tt class="literal">/factories/cf</tt>. The connection factory will use the default
        remoting connector. To use a different remoting connector with the connection factory
        change the <tt class="literal">Connector</tt> attribute to specify the service name of the connector you wish to use.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conf.connectionfactory.attributes"></a>8.7.1.&nbsp;
           We now discuss the MBean attributes of the ConnectionFactory MBean
       </h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.clientid"></a>8.7.1.1.&nbsp;ClientID</h4></div></div><div></div></div><p>
              Connection factories can be pre-configured with a client id. Any connections created using this connection factory will obtain this client id
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.jndibindings"></a>8.7.1.2.&nbsp;JNDIBindings</h4></div></div><div></div></div><p>
              Returns a list of the JNDI bindings for this connection factory
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.prefetchsize"></a>8.7.1.3.&nbsp;PrefetchSize</h4></div></div><div></div></div><p>
            Each client side consumer maintains a local buffer of messages from which it consumes. The server typically sends messages as fast as it can
            to the consumer, and when the consumer is full it sends the server a "stop" message to say it is full.
            When it clears enough space it sends a "start" message to ask the server to continue sending messages.
            The prefetchSize determines the size of this buffer. Larger values give better throughput.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.tempqueuepaging"></a>8.7.1.4.&nbsp;Temporary queue paging parameters</h4></div></div><div></div></div><p>DefaultTempQueueFullSize, DefaultTempQueuePageSize, DefaultTempQueueDownCacheSize are optional attributes that determine the default paging parameters to be used for
       any temporary destinations scoped to connections created using this connection factory. See the section on paging channels for more information
       on what these values mean.
       They will default to values of 200000, 2000 and 2000 respectively if ommitted.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.dupsokbatchsize"></a>8.7.1.5.&nbsp;DupsOKBatchSize</h4></div></div><div></div></div><p>When using a session with acknowledge mode of DUPS_OK_ACKNOWLEDGE this setting determines how many acknowledgments it will buffer locally
      before sending. The default value is <tt class="literal">2000</tt>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="conf.destination.connectionfactory.attributes.connector"></a>8.7.1.6.&nbsp;Connector</h4></div></div><div></div></div><p>This specifies which remoting connector this connection factory uses. Different connection factories can use different connectors.
         </p><p>For instance you could deploy one connection factory that creates connections that use the HTTP transport to communicate to the server and another
         that creates connections that use the bisocket transport to communicate.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.connector"></a>8.8.&nbsp;Configuring the remoting connector</h2></div></div><div></div></div><p>
         JBoss Messaging uses JBoss Remoting  for all client to server communication.
         For full details of what JBoss Remoting is capable of and how it is configured please
         consult the JBoss Remoting documentation.
      </p><p>
         The default configuration includes a single remoting connector which is used by the
         single default connection factory. Each connection factory can be configured to use
         its own connector.
      </p><p>
         The default connector is configured to use the remoting bisocket transport. The bisocket transport is a TCP socket based transport
         which only listens and accepts connections on the server side. I.e. connections are always initiated from the client side. This means
         it works well in typical firewall scenarios where only inbound connections are allowed on the server. Or where onlu outbound connections are
         allowed from the client.
      </p><p>
        The bisocket transport can be configured to use SSL where a higher level of security is required.
        </p><p>
        The other supported transport is the HTTP transport. This uses the HTTP protocol to communicate between client and server. Data is received on the client
        by the client periodically polling the server for messages. This transport is well suited to situations where there is a firewall between client and server
        which only allows incoming HTTP traffic on the server.
        Please note this transport will not be as performant as the bisocket transport due to the nature of polling and the HTTP protocl. Also please note it is not
        designed for high load situations.
      </p><p>No other remoting transports are currently supported by JBoss Messaging</p><p>
         You can look at remoting configuration under:
       </p><p>
          &lt;JBoss&gt;/server/&lt;YourMessagingServer&gt;/deploy/jboss-messaging.sar/remoting-service.xml
       </p><p>
          By default JBoss Messaging binds to ${jboss.bind.address} which can be defined by:
          ./run.sh -c &lt;yourconfig&gt; -b yourIP.
       </p><p>
          You can change remoting-service.xml if you want for example use a
          different communication port.
       </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>Please be wary of changing other settings as they can have an adverse effect on the system</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.servicebindingmanager"></a>8.9.&nbsp;ServiceBindingManager</h2></div></div><div></div></div><p>If you are using the JBoss AS ServiceBindingManager to provide different servers with different port ranges, then you must make sure that the JBoss Messaging
     remoting configuration specified in the JBoss Messaging section of the ServiceBindingManager xml file exactly matches that in remoting-service.xml
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conf.callback"></a>8.10.&nbsp;Configuring the callback</h2></div></div><div></div></div><p>
         JBoss Messaging uses a callback mechanism from Remoting that needs a Socket for callback operations. These socket properties are passed to the server by a remote call when the connection is being estabilished. As we said before we will support bidirectional protocols in future releases.
      </p><p>
         By default JBoss Messaging will execute InetAddress.getLocalHost().getHostAddress() to access your local host IP, but in case you need to setup a different IP, you can define a system property in your java arguments:
      </p><p>
      Use java -Djboss.messaging.callback.bind.address=YourHost - That will determine the callBack host in your client.
      </p><p>
      The client port will be selected randomly for any non used port. But if you defined -Djboss.messaging.callback.bind.port=NumericPort in your System Properties that number is going to be used for the call back client port.
      </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="c_configuration"></a>Chapter&nbsp;9.&nbsp;JBoss Messaging Clustering Configuration</h2></div></div><div></div></div><p>
      In this chapter we will discuss how to configure JBoss Messaging clustering for different types of applications
   </p><p>
      Most of JBoss messaging clustering configuration revolves around the following variable:
   </p><div class="itemizedlist"><ul type="disc"><li>Choosing the cluster router policy</li><li>Choosing the message redistributon policy</li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clusterrouter"></a>9.1.&nbsp;Choosing the cluster router policy</h2></div></div><div></div></div><p>

      When a message is sent to a queue on particular node of the cluster, the system must decide whether the current node will handle it or whether it should send
      it to another node to handle.
      </p><p> The same applies if there are shared durable subscriptions on a topic and the message is being sent to a topic
      </p><p>The correct decision to make depends on your application topology.</p><p>If your application consists of a set of servers with the same MDBs deployed on each server, and you have many well distributed producers sending
      messages on all the nodes of the cluster, then the best policy is to always favour the local queue, since extra network trips are more expensive and the other
      nodes are also havng local messages sent to them</p><p>However if your application consists of a set of homogenous MDBs but you have few or badly distributed producers, then always favouring the local producer
      will mean the other nodes are being starved of messages and not using their CPUs cycles efficiently for messaging processing.</p><p>In this case, a good policy is to use a round robin routing policy where messages are round robin distributed to different nodes as they arrive.</p><p>In general, use the DefaultRoutingPolicy (this always favours the local queue) if you have many well distributed producers, and use the
      RoundRobinRoutingPolicy if you have few or badly distributed producers.</p><p>This are specified in the clustered post office config, by specifying the following attribute</p><p>To favour the local queue:</p><pre class="programlisting">
       &lt;attribute name="ClusterRouterFactory"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.DefaultRouterFactory&lt;/attribute&gt;
      </pre><p>To round robin:</p><pre class="programlisting">
         &lt;attribute name="ClusterRouterFactory"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.RoundRobinRouterFactory&lt;/attribute&gt;
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="messagepull"></a>9.2.&nbsp;Choosing the message pull policy</h2></div></div><div></div></div><p>Once messages have arrived on queues in a cluster, in an ideal world they will all be consumed at the same rate, and there will be consumers on each node.
      </p><p>However, in some application topologies, consumes may close on queues on a node, leaving messages otherwise stranded, or perhaps consumers
      on some nodes are fast than consumers on other nodes causing messages to build up on one node or another and adversely effecting latency.
      </p><p>JBoss Messaging allows messages to pulled from one node to another as load dictates in order to cope with such situations</p><p>Whether or not you should activate message pulling (message redistribution) depends on your application topology</p><p>For an application that consists of a set of servers with a heterogenous bank of MDBs (or other consumers) deployed on each node, consuming at
      approximately the same rate, then message redistribution is not necessary.
      </p><p>However, if your application consists of different numbers or rates of consumers on different nodes then message redistribution may help</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>By its nature, message redistribution can result in messages being delivered in an order different to the strict ordering imposed by JMS. I.e.
      messages can, sometimes be delivered in an order different to that which they were produced by their producer. If this ordering is important to you
      then don't use message redistribution</div><p>In general, use message redistribution when your consumers are not well distributed across the cluster or if they have greatly varying rates.</p><p>Message redistribution is set by setting the following attribute in the clustered post office configuration:
      </p><p>
      For no message redistribution:
      </p><pre class="programlisting">
           &lt;attribute name="MessagePullPolicy"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.NullMessagePullPolicy&lt;/attribute&gt;
      </pre><p>For message redistribution:</p><pre class="programlisting">
           &lt;attribute name="MessagePullPolicy"&gt;org.jboss.messaging.core.plugin.postoffice.cluster.DefaultMessagePullPolicy&lt;/attribute&gt;
      </pre><p>When selecting message redistribution you should also choose a value of <tt class="literal">StatsSendPeriod</tt> appropriately.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;10.&nbsp;Generating Performance Benchmark Results</h2></div></div><div></div></div><p>
      As we discussed in <a href="#about" title="Chapter&nbsp;1.&nbsp;Introducing JBoss Messaging Release 1.2.0.GA">Chapter&nbsp;1, <i>Introducing JBoss Messaging Release 1.2.0.GA</i></a>, the key advantage of JBoss Messaging is
      its superior performance. In fact, the JBoss Messaging comes with a set of standard
      performance test. You can run them on your server and generate your own performance
      benchmark results. In this chapter, we will show you how to run a JBoss Messaging server
      and a JBossMQ server side-by-side on a single machine, and compare their performance.
      To get the performance tests, you have to obtain the JBoss Messaging source code from SVN
      as described in <a href="#gettingstarted" title="Chapter&nbsp;4.&nbsp;Download Software">Chapter&nbsp;4, <i>Download Software</i></a>.
  </p><p>
    To get the performance tests, you first need to check out the source code and build the project. The location of the framework's source code will be
    referred to as $PERF_HOME throughout the rest of the document.
  </p><pre class="programlisting">
svn co https://svn.jboss.org/repos/messaging/projects/perf/trunk messaging-perf
cd $PERF_HOME
ant
  </pre><p>The test consists in sending bursts of 1000 0 Kilobytes non-persistent messages to both JBoss Messaging and JBossMQ instances while gradually increasing the send rate (200 messages/sec, 400 messages/sec, etc) and measuring the receive rate. At the end, the framework generates the graph representing the receive rate as function of the send rate for two executions (JBoss Messaging and JBossMQ).</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2210"></a>10.1.&nbsp;Run JBoss Messaging and JBossMQ Side-by-side</h2></div></div><div></div></div><p>
        To run performance tests side-by-side on the same machine, we assume that you create
        two JBoss AS configurations with the JBoss Messaging and JBossMQ modules respectively.
        We assume that the JBoss Messaging module is installed in the
        <tt class="literal">server/messaging</tt> directory (see <a href="#installation" title="Chapter&nbsp;5.&nbsp;JBoss Messaging Non-Clustered Installation">Chapter&nbsp;5, <i>JBoss Messaging Non-Clustered Installation</i></a>),
        and the default JBossMQ module is installed in <tt class="literal">server/jbossmq</tt>
        directory (just copy the original <tt class="literal">default</tt> directory that comes with
        the server).</p><p>Now, if you run the two configurations on the same server, there will be port conflicts. To avoid that, we use the JBoss <tt class="literal">ServiceBindingManager</tt> to increase the port numbers in the <tt class="literal">jbossmq</tt> configuration by 100 (i.e., the JNDI service will be available at port 1199 instead of 1099). To do that, un-comment the following line in <tt class="literal">server/jbossmq/conf/jboss-service.xml</tt></p><pre class="programlisting">
&lt;mbean code="org.jboss.services.binding.ServiceBindingManager"
       name="jboss.system:service=ServiceBindingManager"&gt;

  &lt;attribute name="ServerName"&gt;ports-01&lt;/attribute&gt;WWWr
  &lt;attribute name="StoreURL"&gt;
    ../docs/examples/binding-manager/sample-bindings.xml
  &lt;/attribute&gt;
  &lt;attribute name="StoreFactoryClassName"&gt;
    org.jboss.services.binding.XMLServicesStoreFactory
  &lt;/attribute&gt;
&lt;/mbean&gt;
    </pre><p>Now, you can start the <tt class="literal">messaging</tt> and <tt class="literal">jbossmq</tt> configurations side-by-side for testing.</p><pre class="programlisting">
run -c messaging
run -c jbossmq
    </pre></div>
sssssssssssd
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2249"></a>10.2.&nbsp;Setup the Tests</h2></div></div><div></div></div><p>The performance framework relies on distributed executors to send messages into the providers being tested. The executors can run standalone in their own VM and act as "remote" JMS connections, or colocated, in which case they are deployed as JBoss services and simulate "colocated" JMS connections.</p><p>In order to correctly deploy the colocated executors, the framework relies on the <tt class="literal">JBOSS_HOME</tt> environment variable. It assumes directories <tt class="literal">$JBOSS_HOME/server/messaging</tt> and <tt class="literal">$JBOSS_HOME/server/jbossmq</tt> exist.</p><pre class="programlisting">
ant sar
ant start-executors
    </pre><p>Next, we need to deploy test message destinations. They are in the <tt class="literal">messaging-destinations-service.xml</tt>, <tt class="literal">jbossmq-destinations-service.xml</tt> files. Feel free to add your own destinations (must add equivalent ones in both files) and then deploy them via the following command.</p><pre class="programlisting">
ant deploy-destinations
    </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2277"></a>10.3.&nbsp;Configure Test Runs</h2></div></div><div></div></div><p>The <tt class="literal">etc/perf.xml</tt> file is used to configure tests. In our setting (i.e., <tt class="literal">jbossmq</tt> runs in +100 port range from default), the <tt class="literal">&lt;providers&gt;</tt> section should look like the following. We can easily run the two JMS server configurations on different machines or in other port ranges. You just need to change the host and port numbers here for tests.</p><pre class="programlisting">
&lt;provider name="JBossMessaging"&gt;
  &lt;factory&gt;org.jnp.interfaces.NamingContextFactory&lt;/factory&gt;
  &lt;url&gt;jnp://localhost:1099&lt;/url&gt;
  &lt;pkg&gt;org.jboss.naming:org.jnp.interfaces&lt;/pkg&gt;
  &lt;executor name="REMOTE" url="rmi://localhost:7777/standalone"/&gt;
  &lt;executor name="REMOTE2" url="rmi://localhost:7777/standalone2"/&gt;
  &lt;executor name="COLOCATED" url="rmi://localhost:7777/local-messaging"/&gt;
  &lt;executor name="COLOCATED2" url="rmi://localhost:7777/local-messaging2"/&gt;
&lt;/provider&gt;

&lt;provider name="JBossMQ"&gt;
  &lt;factory&gt;org.jnp.interfaces.NamingContextFactory&lt;/factory&gt;
  &lt;url&gt;jnp://localhost:1199&lt;/url&gt;
  &lt;pkg&gt;org.jboss.naming:org.jnp.interfaces&lt;/pkg&gt;
  &lt;executor name="REMOTE" url="rmi://localhost:7777/standalone"/&gt;
  &lt;executor name="REMOTE2" url="rmi://localhost:7777/standalone2"/&gt;
  &lt;executor name="COLOCATED" url="rmi://localhost:7777/local-jbossmq"/&gt;
  &lt;executor name="COLOCATED2" url="rmi://localhost:7777/local-jbossmq2"/&gt;
&lt;/provider&gt;
    </pre><p>The performance configuration section configures how to ramp up the load from 200 messages / sec to 3000 message / sec. We will gather statistics on the number of processed messages versus the number of sent messages.</p><pre class="programlisting">
&lt;performance-test name="Throughput O KB Message
   Non-Persistent Non-Transactional, 1 sender, 1 receiver"&gt;

  &lt;message-size&gt;0&lt;/message-size&gt;
  &lt;messages&gt;10000&lt;/messages&gt;

  &lt;drain/&gt;

  &lt;parallel&gt;
    &lt;send rate="200" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="400" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="800" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="1000" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="1500" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="2000" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="2500" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;parallel&gt;
    &lt;send rate="3000" executor="COLOCATED"/&gt;
    &lt;receive executor="COLOCATED2"/&gt;
  &lt;/parallel&gt;

  &lt;execution provider="JBossMessaging"/&gt;
  &lt;execution provider="JBossMQ"/&gt;

&lt;/performance-test&gt;
    </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2297"></a>10.4.&nbsp;Run the Tests</h2></div></div><div></div></div><p>To run the tests, simply execute <tt class="literal">ant run</tt> from the command line. You can access the benchmark result graphs from <tt class="literal">output/results/benchmark-results.html</tt>.</p><p>After running the test, you can clean up the executors and test destinations using the following commands.</p><pre class="programlisting">
ant stop-executors
ant undeploy-destinations
    </pre></div></div></div></body></html>